<!DOCTYPE html>
<head>
<title>cs_assault by Raycaster</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
<link rel="shortcut icon" href="./assets/favicon.ico">
<link href="https://fonts.googleapis.com/css?family=Roboto:100,300,400,700" rel="stylesheet">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/solid.css" integrity="sha384-r/k8YTFqmlOaqRkZuSiE9trsrDXkh07mRaoGBMoDcmA58OHILZPsk29i2BsFng1B" crossorigin="anonymous">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/fontawesome.css" integrity="sha384-4aon80D8rXCGx9ayDt85LbyUHeMWd3UiBaWliBlJ53yzm9hqN21A+o1pqoyK04h+" crossorigin="anonymous">
<style>
@font-face {
  font-family: 'csFont';
  src: URL('./assets/cs_regular.ttf') format('truetype');
}
body {
	width: 100vw;
	max-width: 100%;
	height: 100vh;
	margin: 0;
	overflow: hidden;
	font-family: 'Roboto', sans-serif;
}
.loading-wrapper {
	width: 300px;
	height: 200px;
	display: flex;
	flex-direction: row;
	align-items: center;
	justify-content: center;
	position: fixed;
	top: 55%;
	left: calc(50% - 150px);
	z-index: 101;
	color: black;
	transition: color 0.5s;
}
.loading-wrapper p {
	font-size: 32px;
	font-weight: bold;
	color: inherit;
}
.white-text {
	color: white !important;
}
#loadingCanvas {
	z-index: 100;
	position: fixed;
	top: 0;
	left: 0;
}
#instructionComponent {
	color: rgba(255, 255, 0, 0.8); 
	background-color: rgba(0,0,0,0.8);
	opacity: 1;
	font-family: 'csFont', monospace;
	font-size: 24px; 
	line-height: 1.2em;
	letter-spacing: 0.0625em;
	position: fixed;
	z-index: 10;
	top: 0;
	left: 0;
	display: flex;
	flex-direction: column;
	align-items: flex-start;
	justify-content: center;
	width: 60%;
	margin: 10%;
	padding: 2% 10%;
	transition: 0.3s;
}
#instructionComponent h1 {
	font-size: 48px; 
}
#instructionComponent h2 {
	/* copyright */
	position: relative;
	font-size: 16px;
	float: right;
	margin-top: 20px;
	line-height: 1em;
}
#instructionComponent ul {
	list-style: none;
	margin: 0;
}
#instructionComponent a:hover {
	color: rgb(255, 255, 255); 
	transition: 0.3s;
}
#toolBarComponent {
	position: fixed;
	top: 50px;
	right: 50px;
	z-index: 11;
	width: 100px;
	height: 50px;
	display: flex;
	flex-direction: row;
	align-items: center;
	justify-content: space-between;
}
#info, #setting {
	position: relative;
}
#info span, #setting span {
	font-size: 24px;
	color: rgb(255, 255, 255);
	transition: 0.3s;
	cursor: pointer;
	opacity: 0.5;
}
#info:hover::after, #setting:hover::after {
	width: 100%;
	position: absolute;
	top: -100%;
	left: -100%;
	font-size: 18px;
	color: white;
	font-weight: bold;
}
#info:hover::after {
	content: 'Instructions';
}
#setting:hover::after {
	content: 'Settings';
}
#settingDropdown {
	position: absolute;
	opacity: 0;
	visibility: hidden;
	right: -10px;
	top: 150%;
	width: 300px;
	background-color: white;
	border-radius: 5px;
	display: flex;
	flex-direction: column;
	align-items: center;
	justify-content: flex-start;
}
#settingDropdown::after {
	content: '';
	position: absolute;
	width: 10px;
	height: 10px;
	top: -5px;
	right: 16px;
	background-color: white;
	transform: rotate(45deg);
}
#settingDropdown span {
	color: black;
	font-weight: bold;
	font-size: 14px;
	opacity: 1;
}
#settingDropdown i {
	margin-left: 10px;
}
#info span:hover, #setting span:hover {
	opacity: 1;
	transition: 0.3s;
}
.settingDropdownItem {
	height: 50px;
	line-height: 50px;
	width: calc(100% - 20px);
	margin: 10px;
	display: flex;
	flex-direction: row;
	align-items: center;
	justify-content: center;
}
.settingDropdownItem:hover {
	background-color: rgba(100,100,100,0.1);
	cursor: pointer;
}
#playerStatusComponent {
	color: rgba(255, 255, 0, 0.8); 
	font-family: 'csFont', monospace;
	letter-spacing: 0.0625em;
	position: fixed;
	left: 10px;
	bottom: 10px;
	display: flex;
	flex-direction: row;
	align-items: flex-start;
	justify-content: center;
	z-index: 10;
	font-size: 32px;
}
.playerStatusGroupWrapper {
	display: flex;
	flex-direction: row;
	align-items: center;
	justify-content: center;
	margin: 0 50px;
}
.playerStatusIcon {
	transform: rotate(45deg);
	margin: 0 10px;
}
.playerStatusValue span {
	margin: 0 5px;
}
#serverMessageComponent {
	position: fixed;
	top: 10px;
	left: 30%;
	width: calc(40% - 20px);
	display: flex;
	flex-direction: column;
	align-items: flex-start;
	justify-content: center;
	z-index: 10;
	transition: opacity 2s;
	background-color: rgb(0, 0, 0, 0.1);
	border-radius: 5px;
	padding: 5px 10px;
}
#serverMessageComponent:hover {
	opacity: 1 !important;
}
.serverMessageItemWrapper {
	width: 100%;
	font-family: 'Roboto', sans-serif;
	color: rgba(255, 255, 0, 0.8); 
	text-align: left;
	font-size: 14px;
}
#scoreBoardComponent {
	z-index: 10;
	position: fixed;
	visibility: hidden;
	opacity: 0;
	transition: 0.5s;
	width: calc(60% - 40px);
	height: calc(80% - 40px);
	top: calc(10% - 20px);
	left: 20%;
	padding: 20px;
	background-color: rgba(0, 0, 0, 0.8);
	display: flex;
	flex-direction: column;
	align-items: center;
	justify-content: flex-start;
	font-family: 'Roboto', sans-serif;
	font-weight: 300;
	color: rgb(255, 255, 255);
	text-align: center;
	font-size: 14px;
}
.scoreBoardRowTitle {
	font-weight: 700 !important;
	border-bottom: 1px solid white;
	margin-bottom: 10px;
}
.scoreBoardRowTitle:hover {
	background-color: rgba(255, 255, 255, 0) !important;
}
.scoreBoardRow {
	display: flex;
	flex-direction: row;
	align-items: center;
	justify-content: flex-start;
	width: 80%;
	margin: 2px 0;
	height: 21px;
	line-height: 21px;
	cursor: pointer;
}
.scoreBoardRow:hover {
	background-color: rgba(255, 255, 255, 0.3);
	cursor: pointer;
}
.scoreBoardRowHighlight {
	background-color: rgba(255, 255, 255, 0.1);
}
.scoreBoardRowItem {
	width: 25%;
}
a{
	text-decoration: none;
	display: block;
	padding: 0 5%;  
}
a:link, a:visited, a:hover, a:active{
	color: inherit;
}
a:hover {
	opacity: 1;
}
</style>
</head>
<body>
<div id='root'></div>
<script>
(function() {
	GlobalVar = function() {
		// global variables
	};
	const 
		width = window.innerWidth,
		height = window.innerHeight,
		assetsUrlObj = {
			sky: './assets/sky.jpg',
			gun: './assets/gun.png',
			muzzle: './assets/muzzle.png',
			emptyBullet: './assets/bullet.png',
			soilder: './assets/soilder.png'
		};
	GlobalVar.prototype.getWindowWidth = function() {
		return width
	};
	GlobalVar.prototype.getWindowHeight = function(){
		return height
	};
	GlobalVar.prototype.getAssetsUrlObj = function(){
		this.assetsCount = Object.keys(assetsUrlObj).length;
		return assetsUrlObj
	}
	GlobalVar.prototype.remapAngleToZeroToTwoPI = function(angle) {
		const twoPI = Math.PI * 2;
		let a = angle % twoPI;
		return a > 0 ? a : twoPI + a
	}
})();
const CONST = new GlobalVar();

(function() {
	// parameters
	Param = function() {
		this.resolution /* it will be divided by window width */ = 1;
		this.resolutionHigh = 1;
		this.resolutionLow = 5;
		//
		this.healthPointMax = 100;
		this.currentMagzineMax = 30;
		this.totalMagzineMax = 240;
		//
		this.recoilStaticMax = 10;
		this.recoilMovingMax = 100;
		this.gunPositionOffsetMax = 10;
		this.gunPositionFiringOffsetMax = 30;
	};
	const mapGrid = 
	[	// 40 * 40, T left wall x is 23
		[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 3, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],
		[1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1],
		[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]   
	];

	const wallColorArray /* [wallType][HitDirection] */= [
			['rgb(75,43,24)', 'rgb(139,79,45)'],
			['rgb(255,255,255)', 'rgb(200,200,200)'],
			['rgb(64, 224, 208)', 'rgb(36,127,118)'],
		];

	const
		initialJumpVelocity /* maximum jump height */ = CONST.getWindowHeight() * 0.01,
		gravity = initialJumpVelocity / 10;

	// miniMap size
	const
		width = CONST.getWindowWidth(),
		height = CONST.getWindowHeight(),
		whicheverIsShorter = Math.min(width, height),
		miniMapMargin = whicheverIsShorter * 0.01,
		miniMapSizeMin = Math.floor(whicheverIsShorter * 0.2),
		miniMapSizeMax = Math.floor(whicheverIsShorter * 0.8),
		miniMapToggleSpeed = (miniMapSizeMax - miniMapSizeMin) / 5;

	Param.prototype.getMiniMapMargin = function() {
		return miniMapMargin
	};
	Param.prototype.getMiniMapSizeMin = function() {
		return miniMapSizeMin
	};
	Param.prototype.getMiniMapSizeMax = function() {
		return miniMapSizeMax
	};
	Param.prototype.getMiniMapToggleSpeed = function() {
		return miniMapToggleSpeed
	};
	//
	Param.prototype.getMapGrid = function() {
		return mapGrid
	};
	Param.prototype.getWallColorArray = function() {
		return wallColorArray
	};
	Param.prototype.getInitialJumpVelocity = function() {
		return initialJumpVelocity
	};
	Param.prototype.getGravity = function() {
		return gravity
	}
})();


function State() {
	// states
	this.currentJumpVelocity = 0;
	this.accumulatedJumpHeight = 0;
	//
	this.isTogglingMiniMap /* 1: enlarging, 0: false, -1: shrinking */ = 0;
	//
	this.gunPositionOffsetX = 0;
	this.gunPositionOffsetY = 0;
	this.gunPositionOffsetXIncrementSign = 1;
	this.gunPositionOffsetYIncrementSign = 1;
	this.isGunPositionFiringOffset = false;
	this.gunPositionFiringOffsetX = 0;
	this.gunPositionFiringOffsetY = 0;
	this.gunPositionFiringOffsetXIncrementSign = 1;
	this.gunPositionFiringOffsetYIncrementSign = 1;
	this.isFiring = false;
	this.isFireRequested = false;
	this.isReloadRequested = false;
	this.isReloading = false;
	this.muzzleRotate = Math.random() * Math.PI * 2;
	this.thisRoundFiringFinished = true;
	this.bulletHitX;
	this.bulletHitY;
	this.bulletHitConfirmed; /* used to change crater color */
	//
	this.canvasCenterTextOpacity = 1;
	this.canvasCenterTextOpacitySign = -1;
	this.isShowingNoAmmoText = false;
	//
	this.healthPoint = param.healthPointMax;
	this.currentMagzine = param.currentMagzineMax;
	this.totalMagzine = param.totalMagzineMax;
	this.isMagzineEmpty = false;
	//
	this.emptyBullets = [];
	// server message
	this.serverMessage = [];
	this.serverMessageTimeout = null;
	// _id for this player
	this.playerId;
	//
	this.latency = 0;
	this.isDisplayingLatency = true;
	this.isLowerGraphicQuality = false;
	//
	this.playersArray = [];
	//
	this.isConnectedToServer = false;
	// hitZone will only be push into array if it was drawn (guaranteed in sight) on frame, this array is cleared on the beginning of draw other players.
	this.hitZone = [];
	this.hitPlayerArray /* the id of the other players being hit by this player in a frame */ = [];
	//
	this.isRespawning = false;
	this.isRepawnProtected = false;
	//
	this.damageIndicator = [];
	//
	this.kill = 0;
	this.death = 0;
}
State.prototype.updateServerMessage = function(newMessage) {
	if (this.serverMessageTimeout) clearTimeout(this.serverMessageTimeout);
	//
	const 
		array = this.serverMessage.slice(),
		serverMessageComponent = document.getElementById('serverMessageComponent');
	serverMessageComponent.style.opacity = 1;
	let 
		innerComponent = '',
		date = new Date(),
		hour = date.getHours() < 10 ? '0' + date.getHours() : date.getHours(),
		minute = date.getMinutes() < 10 ? '0' + date.getMinutes() : date.getMinutes(),
		second = date.getSeconds() < 10 ? '0' + date.getSeconds() : date.getSeconds();
	if (array.length === 5) {
		array.shift()
	}

	date = hour + ':' + minute + ':' + second;
	newMessage = date + ' ' + '-' + ' ' + newMessage;
	array.push(newMessage);
	array.map(msg => {
		innerComponent += '<div class="serverMessageItemWrapper">' + msg + '</div>';
	});

	serverMessageComponent.innerHTML = innerComponent;
	this.serverMessage = array;

	this.serverMessageTimeout = setTimeout(() => {
		serverMessageComponent.style.opacity = 0;
		this.serverMessageTimeout = null;
	}, 15000) 
}
State.prototype.updateGunPostion = function(isFiring=false) {
	if (!isFiring) {
		// when moving
		let 
			incrementX = Math.random(),
			incrementY = Math.random(),
			nextOffsetX = this.gunPositionOffsetX + incrementX * this.gunPositionOffsetXIncrementSign,
			nextOffsetY = this.gunPositionOffsetY + incrementY * this.gunPositionOffsetYIncrementSign;
		if (Math.abs(nextOffsetX) > param.gunPositionOffsetMax) {
			this.gunPositionOffsetXIncrementSign *= -1;
			nextOffsetX = this.gunPositionOffsetX + incrementX * this.gunPositionOffsetXIncrementSign;
		}
		if (Math.abs(nextOffsetY) > param.gunPositionOffsetMax) {
			this.gunPositionOffsetYIncrementSign *= -1;
			nextOffsetY = this.gunPositionOffsetY + incrementY * this.gunPositionOffsetYIncrementSign;
		}
		this.gunPositionOffsetX = nextOffsetX;
		this.gunPositionOffsetY = nextOffsetY;
	} else {
		// when firing (recoil)
		if (this.isGunPositionFiringOffset) {
			this.gunPositionFiringOffsetX = 0;
			this.gunPositionFiringOffsetY = 0;
			this.isGunPositionFiringOffset = false;
		} else {
			let 
				gunPositionFiringOffsetMax = param.gunPositionFiringOffsetMax,
				offsetX = gunPositionFiringOffsetMax * 0.5 + Math.random() * gunPositionFiringOffsetMax * 0.5,
				offsetY = gunPositionFiringOffsetMax * 0.5 + Math.random() * gunPositionFiringOffsetMax * 0.5;
			nextOffsetX = this.gunPositionFiringOffsetX + offsetX * this.gunPositionFiringOffsetXIncrementSign;
			nextOffsetY = this.gunPositionFiringOffsetY + offsetY * this.gunPositionFiringOffsetYIncrementSign;
			this.gunPositionFiringOffsetXIncrementSign *= -1;
			this.gunPositionFiringOffsetYIncrementSign *= -1;
			this.gunPositionFiringOffsetX = nextOffsetX;
			this.gunPositionFiringOffsetY = nextOffsetY;
			this.isGunPositionFiringOffset = true;
		}
	}
}
State.prototype.getGunPostion = function() {
	const
		width = CONST.getWindowWidth(),
		height = CONST.getWindowHeight(),
		gunPosStartX = 0.5*width + this.gunPositionOffsetX + this.gunPositionFiringOffsetX,
		gunPosStartY = 0.6*height + this.gunPositionOffsetY + param.gunPositionOffsetMax + this.gunPositionFiringOffsetY + param.gunPositionFiringOffsetMax,
		gunWidth = 0.4*width,
		gunHeight = 0.4*height;
	return [gunPosStartX, gunPosStartY, gunWidth, gunHeight]
}
// init objects
const 
	param = new Param(),
	state = new State(),
	game = new Game(),
	serverConnection = new ServerConnection();

function Player() {
	this.isCT = (Math.random() > 0.5);
	this.x /* init coordinate x */ ;
	this.y /* init coordinate y */ ;
	this.alpha /* init direction angle, relative to positive x axis */ ;
	this.forward = false;
	this.backward = false;
	this.clockwise = false;
	this.counterClockwise = false;
	this.moveSpeed = 0.05;
	this.rotateSpeed = 0.01;
	this.mapGrid = param.getMapGrid();
	this.totalMagzine = 120;
	// related to jump function
	this.gravity = param.getGravity();
}
Player.prototype.respawn = function() {
	state.healthPoint = param.healthPointMax;
	const hpEl = document.getElementById('playerStatusHealthPoint');
	hpEl.innerHTML = state.healthPoint;

	const CTRespawn = [[3, 10], [3, 15], [3, 20], [3, 25], [3, 30]];
	const TRespawn = [[25, 16], [25, 27], [26, 17], [34, 16], [34, 17]];
	const respawnPos = Math.floor(Math.random() * 5);
	this.x = this.isCT ? CTRespawn[respawnPos][0] : TRespawn[respawnPos][0];
	this.y = this.isCT ? CTRespawn[respawnPos][1] : TRespawn[respawnPos][1];
	this.alpha = Math.random() > 0.5 ? (-0.75 * Math.PI * 2) /* up */: (0.25 * Math.PI * 2) /* down */;
	this.forward = false;
	this.backward = false;
	this.clockwise = false;
	this.counterClockwise = false;

	// respawned
	if (state.isRespawning) state.isRespawning = false;
	state.isRepawnProtected = true;
	setTimeout(() => state.isRepawnProtected = false, 3000);
}
Player.prototype.move = function() {
	// update player coordinate
	let moveState = this.forward ? 1 : this.backward ? -1 : 0;
	let rotateState = this.clockwise ? 1 : this.counterClockwise ? -1 : 0;

	if (moveState) {
		const nextX = this.x + this.moveSpeed * Math.cos(this.alpha) * moveState;
		const nextY = this.y + this.moveSpeed * Math.sin(this.alpha) * moveState;
		if (this.mapGrid[Math.floor(this.y)][Math.floor(nextX)] === 0) {
			this.x = nextX;
		}
		if (this.mapGrid[Math.floor(nextY)][Math.floor(this.x)] === 0) {
			this.y = nextY;
		}

		// update gun position when walking
		state.updateGunPostion(false);
	}

	if (rotateState) {
		this.alpha = this.rotateSpeed * rotateState + this.alpha;
	}

	//jump
	let currentJumpVelocity = state.currentJumpVelocity;
	const 
		gravity = this.gravity,
		jumpHeihtInThisFrame /* vt, t=1 here */ = currentJumpVelocity,
		accumulatedJumpHeightAfterThisJump = state.accumulatedJumpHeight + jumpHeihtInThisFrame;
	
	if (accumulatedJumpHeightAfterThisJump > 0) {
		// still jumping
		state.currentJumpVelocity = currentJumpVelocity - gravity;
		state.accumulatedJumpHeight += jumpHeihtInThisFrame;
	} else {
		// returned ground
		state.currentJumpVelocity = 0;
		state.accumulatedJumpHeight = 0;
	}

	// firing
	const 
		currentMagzineText  = document.getElementById('plaerStatusCurrentMagzine'),
		totalMagzineText  = document.getElementById('plaerStatusTotalMagzine');

	const reload = () => {
		if (state.currentMagzine === param.currentMagzineMax) {
			// full mag, no need to reload
			state.isReloadRequested = false;
			return;
		}
		state.isReloading = true;
		state.isFiring = false;
		state.thisRoundFiringFinished = true;
			setTimeout(() => {
				const roundRequired = param.currentMagzineMax - state.currentMagzine;
				if (roundRequired <= state.totalMagzine) {
					// normal reloading
					state.currentMagzine = param.currentMagzineMax;
					state.totalMagzine -= roundRequired;
				} else {
					// last mag not enough for full reload
					state.currentMagzine += state.totalMagzine;
					state.totalMagzine = 0;
				}

				if (state.totalMagzine === 0) {
					// mag empty
					const red = 'rgba(255, 69, 0, 1)';
					state.isMagzineEmpty = true;
					currentMagzineText.style.color = red;
					totalMagzineText.style.color = red;
				}
				// update text
				currentMagzineText.innerHTML = state.currentMagzine;
				totalMagzineText.innerHTML = state.totalMagzine;
				state.isReloading = false;
				state.isReloadRequested = false;
			}, 1000)
	};
	const fireNewRound = () => {
		const currentMagzine = state.currentMagzine;
		if (currentMagzine) {
			// do fire
			state.isFiring = true;
			state.thisRoundFiringFinished = false;
			state.muzzelRotate = Math.random() * Math.PI * 2;
			state.currentMagzine--;
			// bullet hit position
			const isMoving = this.forward || this.backward || state.currentJumpVelocity;
			const recoil = isMoving ? param.recoilMovingMax : param.recoilStaticMax;
			const bulletHitX = CONST.getWindowWidth() * 0.5 + (Math.random() - 0.5) * recoil;
			const bulletHitY = CONST.getWindowHeight() * 0.5 + (Math.random() - 0.5) * recoil;
			state.bulletHitX = bulletHitX;
			state.bulletHitY = bulletHitY;
			state.bulletHitConfirmed = false;
			// check hit
			if (state.hitZone.length) {
				state.hitZone.map(i => {
					// [otherplayer.playerId, drawX. drawY, drawWidth, drawHeight]
					const isHit = (i[1] < bulletHitX) && (bulletHitX < (i[1] + i[3])) && (i[2] < bulletHitY) && (bulletHitY < (i[2] + i[4]));
					if (isHit) {
						state.hitPlayerArray.push(i[0]);
						state.bulletHitConfirmed = true;
					}
				});
			}
			// update text
			currentMagzineText.innerHTML = state.currentMagzine;
			setTimeout(() => {
				state.thisRoundFiringFinished = true;
			}, 100)
			// recoil
			state.updateGunPostion(true);
			// eject bullet shell
			const 
				gunPosition = state.getGunPostion(),
				gunPosStartX = gunPosition[0],
				gunPosStartY = gunPosition[1],
				gunWidth = gunPosition[2],
				gunHeight = gunPosition[3],
				emptyBulletX = gunPosStartX + (10 / 20.8) * gunWidth,
				emptyBulletY = gunPosStartY + (3.6 / 13.2) * gunHeight,
				baseSpeed = gunWidth /* 0.4width */ * 0.05,
				speedX = Math.random() * baseSpeed + baseSpeed,
				speedY = Math.random() * -baseSpeed - baseSpeed,
				thisRound = [emptyBulletX, emptyBulletY, speedX, speedY];
			state.emptyBullets.push(thisRound);
		} else if (state.isMagzineEmpty) {
			// empty mag, not fire
			state.isFireRequested = false;
			if (!state.isShowingNoAmmoText) {
				state.isShowingNoAmmoText = true;
				setTimeout(() => {
					state.isShowingNoAmmoText = false;
				}, 1000)
			}
		} else if (!state.isMagzineEmpty) {
			// reload, not fire
			state.isReloadRequested = true;
		}
	};

	if (state.isReloading) {
		
	} else if (state.isReloadRequested && !state.isMagzineEmpty) {
		reload()
	} else if (state.isFireRequested && state.thisRoundFiringFinished) {
		fireNewRound()
	} else if (!state.isFireRequested && state.isFiring) {
		// enter key released
		state.isFiring = false;
	}
	// firing ends

	// bullet shells, move all items in state.bullets
	if (state.emptyBullets.length) {
		const 
			width = CONST.getWindowWidth(),
			height = CONST.getWindowHeight(),
			emptyBulletGravity = width * 0.005;
		state.emptyBullets.map((i) => {
			i[0] += i[2];	/* update X */
			i[1] += i[3];	/* update Y */
			i[3] += emptyBulletGravity; /* update speedY */
		});
		state.emptyBullets.filter(i => {
			// filter bullets out of border
			i[0] > width || i[0] < 0 || i[1] > height || i[1] < 0
		})
	}
};
function Game() {
	this.mainPlayer;
	this.otherPlayers = [];
	//
	this.wallDistArray = [];
	this.hitWallTypeArray = [];
	this.hitDirectionArray = [];
	this.rayAngleArray = [];
	this.wallDistArrayBeforeFishEyeCorrection = []; // for drawing ray on minimap
	this.fov = Math.PI / 3; //60 degree
	this.dAlpha; /* angle between rays */
	// get vars from param
	this.mapGrid = param.getMapGrid();
	//
	this.drawDamageIndicatorArray = [];
	//
	this.deathTimeStamp; // used in respawn frame
	this.respawnFramethrottler = 1;
	//
	this.miniMapSizeMax = param.getMiniMapSizeMax();
	this.miniMapSizeMin = param.getMiniMapSizeMin();
	this.miniMapSize = this.miniMapSizeMin;
	this.miniMapMargin = param.getMiniMapMargin();
	this.miniMapToggleSpeed = param.getMiniMapToggleSpeed();
}
Game.prototype.initiateCanvas = function() {
	const rootDiv = document.getElementById('root');
	const container = document.createElement('div');
	rootDiv.appendChild(container);
	const width = CONST.getWindowWidth();
	const height = CONST.getWindowHeight();

	const mainCanvas = `<canvas id="mainCanvas" width=${width} height=${height}>Your Browser Does Not Support Html5 Canvas</canvas>`;
	container.innerHTML = mainCanvas;

	// instructionComponent
	const instructionComponent = new InstructionComponent();
	instructionComponent.mountComponent();
	// toolbar
	const toolBarComponent = new ToolBarComponent();
	toolBarComponent.mountComponent();
	// player status
	const playerStatusComponent = new PlayerStatusComponent();
	playerStatusComponent.mountComponent();
	// server message
	const serverMessageComponent = new ServerMessageComponent();
	serverMessageComponent.mountComponent();
	state.updateServerMessage('Establishing connection to server');
	// scoreboard
	const scoreBoardComponent = new ScoreBoardComponent();
	scoreBoardComponent.mountComponent();
};
Game.prototype.createMainPlayer = function() {
	this.mainPlayer = new Player();
	this.mainPlayer.respawn();
};
Game.prototype.ray = function() {
	//Prepare rayArray
	const 
		rayAngleArray = [],
		raydistArray = [],
		raydistArrayFishEyeCorrected = [],
		hitDirectionArray = [],
		hitWallTypeArray = [],
		mapGrid = this.mapGrid,
		width = CONST.getWindowWidth(),
		height = CONST.getWindowHeight(),
		resolution = param.resolution,
		dAlpha = (this.fov / (width / resolution));
	this.dAlpha = dAlpha;
	let rayAngle /* init first ray */ = this.mainPlayer.alpha - 0.5 * this.fov;
	//
	for (let i = 0; i < width; i += resolution) {
		rayAngleArray.push(rayAngle);
		rayAngle += dAlpha;
	}
	//
	rayAngleArray.map((i, index) => {
		const 
			result = raycaster(this.mainPlayer.x, this.mainPlayer.y, rayAngleArray[index]),
			dist = result[0],
			hitDirection = result[1],
			hitWallType = result[2],
			fishEyeCorrection = Math.abs(Math.cos(rayAngleArray[index] - this.mainPlayer.alpha));

		raydistArray.push(dist);
		raydistArrayFishEyeCorrected.push(dist * fishEyeCorrection);
		hitDirectionArray.push(hitDirection);
		hitWallTypeArray.push(hitWallType);
	})
	// update arrays in properties
	this.wallDistArrayBeforeFishEyeCorrection = raydistArray;
	this.wallDistArray = raydistArrayFishEyeCorrected;
	this.hitWallTypeArray = hitWallTypeArray;
	this.hitDirectionArray = hitDirectionArray;
	this.rayAngleArray = rayAngleArray;

	// raycaster
	function raycaster(x, y, alpha) {
		//input origin x,y and angle alpha, return distance.
		function checkHit (x, y) {
			// hit if grid value is not 0
			return mapGrid[y][x] !== 0
		}
		const 
			sin = Math.sin(alpha),
			cos = Math.cos(alpha),
			tan = Math.tan(alpha),
			result = [];
		// temp variables used for calculation
		let vx, vy, hx, hy, dist, distV, distH, hitDirection /* 0: horizontal, 1:vertical */, hitWallType;

		//2 tan>0 x++ y++
		if (sin >= 0 && cos > 0) {
			//vertical
			vx = Math.ceil(x);
			vy = Math.min(y + tan * (vx - x), 39);
			while (!checkHit(Math.floor(vx),Math.floor(vy))) {
				vx++;
				vy = Math.min(vy + tan, 39);
			}
			//horizontal
			hy = Math.ceil(y); //DO NOT REVERSE HY HX!
			hx = x + (hy - y)/tan;
			while (!checkHit(Math.floor(hx),Math.floor(hy))) {
				hx += 1/tan;
				hy++;
			}
			distV = Math.pow((vx-x)*(vx-x)+(vy-y)*(vy-y), 0.5);
			distH = Math.pow((hx-x)*(hx-x)+(hy-y)*(hy-y), 0.5);
			if (distV >= distH) {
				dist = distH;
				hitDirection = 0;
				hitWallType = mapGrid[Math.floor(hy)][Math.floor(hx)];
			} else {
				dist = distV;
				hitDirection = 1;
				hitWallType = mapGrid[Math.floor(vy)][Math.floor(vx)];
			}
		}
		
		//4 tan<0 x-- y++
		if (sin > 0 && cos <= 0) {
			//vertical
			vx = Math.floor(x);
			vy = Math.min(y + tan * (vx - x), 39);
			while (!checkHit(Math.floor(vx)-1,Math.floor(vy))) {
				vx--;
				vy = Math.min(vy - tan, 39);
			}
			//horizontal
			hy = Math.ceil(y); //DO NOT REVERSE HY HX!
			hx = x + (hy - y)/tan;
			while (!checkHit(Math.floor(hx),Math.floor(hy))) {
				hx += 1/tan;
				hy++;
			}
			distV = Math.pow((vx-x)*(vx-x)+(vy-y)*(vy-y),0.5);
			distH = Math.pow((hx-x)*(hx-x)+(hy-y)*(hy-y),0.5);
			if (distV >= distH) {
				dist = distH;
				hitDirection = 0;
				hitWallType = mapGrid[Math.floor(hy)][Math.floor(hx)];
			} else {
				dist = distV;
				hitDirection = 1;
				hitWallType = mapGrid[Math.floor(vy)][Math.floor(vx)-1];
			}
		}
		
		//6 tan>0 x-- y--
		if (sin <= 0 && cos < 0) {
			//vertical
			vx = Math.floor(x);
			vy = Math.max(y + tan * (vx - x), 1);
			while (!checkHit(Math.floor(vx)-1,Math.floor(vy))) {
				vx--;
				vy = Math.max(vy - tan, 1);
			}
			//horizontal
			hy = Math.floor(y); //DO NOT REVERSE HY HX!
			hx = x + (hy - y)/tan;
			while (!checkHit(Math.floor(hx),Math.floor(hy)-1)) {
				hx -= 1/tan;
				hy--;
			}
			distV = Math.pow((vx-x)*(vx-x)+(vy-y)*(vy-y),0.5);
			distH = Math.pow((hx-x)*(hx-x)+(hy-y)*(hy-y),0.5);
			if (distV >= distH) {
				dist = distH;
				hitDirection = 0;
				hitWallType = mapGrid[Math.floor(hy)-1][Math.floor(hx)];
			} else {
				dist = distV;
				hitDirection = 1;
				hitWallType = mapGrid[Math.floor(vy)][Math.floor(vx)-1];
			}
		}
		
		//8 tan<0 x++ y--
		if (sin < 0 && cos >= 0) {
			//vertical
			vx = Math.ceil(x);
			vy = Math.max(y + tan * (vx - x), 1);
			while (!checkHit(Math.floor(vx),Math.floor(vy))) {
				vx++;
				vy = Math.max(vy + tan, 1);
			}
			//horizontal
			hy = Math.floor(y); //DO NOT REVERSE HY HX!
			hx = x + (hy - y)/tan;
			while (!checkHit(Math.floor(hx),Math.floor(hy)-1)) {
				hx -= 1/tan;
				hy--;
			}
			distV = Math.pow((vx-x)*(vx-x)+(vy-y)*(vy-y),0.5);
			distH = Math.pow((hx-x)*(hx-x)+(hy-y)*(hy-y),0.5);
			if (distV >= distH) {
				dist = distH;
				hitDirection = 0;
				hitWallType = mapGrid[Math.floor(hy)-1][Math.floor(hx)];
			} else {
				dist = distV;
				hitDirection = 1;
				hitWallType = mapGrid[Math.floor(vy)][Math.floor(vx)];
			}
		}
		
		//
		result.push(dist);
		result.push(hitDirection);
		result.push(hitWallType);
		return result;
	}
};
Game.prototype.drawFrame = function() {
	const 
		width = CONST.getWindowWidth(),
		height = CONST.getWindowHeight(),
		ctx = document.getElementById('mainCanvas').getContext('2d');
	ctx.clearRect(0, 0, width, height);
// resolution
	param.resolution = state.isLowerGraphicQuality ? param.resolutionLow : param.resolutionHigh;
// sky
	const
		sky = document.getElementById("sky"),
		skyWidth = sky.width,
		skyHeight = sky.height,
		playerAlpha =  this.mainPlayer.alpha,
		twoPI = Math.PI * 2,
		cameraAngle = playerAlpha % twoPI,
		direction = cameraAngle > 0 ?
			cameraAngle / twoPI :
			(twoPI + cameraAngle) / twoPI;

	ctx.drawImage(sky, direction*skyWidth, 0, 0.25*skyWidth, skyHeight, 0, 0, width, 0.6*height);
	if (direction >= 0.75) {
		ctx.drawImage(sky, 0, 0, 0.25*skyWidth, skyHeight, (1-direction)/0.25*width, 0, width, 0.6*height);
	}
// floor
	ctx.beginPath();
	ctx.fillStyle = 'rgba(150,150,150,1)';
	ctx.fillRect(0, 0.5 * height, width, 0.5 * height);
	ctx.fill();
// wall
	const wallDistArray = this.wallDistArray.slice();
	wallDistArray.map((i, index) => {
		const 
			columnHeightPercent = 3 / i,
			halfWallHeight = 0.5 * columnHeightPercent * height,
			mid = 0.5 * height,
			wallStart = mid - halfWallHeight,
			wallEnd = mid + halfWallHeight,
			hitWallType = this.hitWallTypeArray[index],
			hitDirection = this.hitDirectionArray[index],
			resolution = param.resolution;

		const wallColorArray = param.getWallColorArray();
		const wallColor = wallColorArray[hitWallType - 1][hitDirection];
		ctx.fillStyle = wallColor;
		ctx.beginPath();
		ctx.fillRect(index * resolution, wallStart + state.accumulatedJumpHeight, resolution, wallEnd - wallStart);
		ctx.fill();
	});

	// otherplayer
	this.otherPlayers.map(otherplayer => {
		if (otherplayer.isInSight) {
			this.drawOtherPlayers(otherplayer, otherplayer.anotherPlayersAngleToMainPlayer, otherplayer.distance, width, height)
		}
	});

	// crosshair
	const isMoving = this.mainPlayer.forward || this.mainPlayer.backward || state.currentJumpVelocity;
	const crosshairSize = isMoving ? 15 : 0;

	ctx.strokeStyle = "rgba(0,255,0,1)";
	ctx.beginPath();
	ctx.moveTo(0.5*width-20-crosshairSize,0.5*height);
	ctx.lineTo(0.5*width-5-crosshairSize,0.5*height);
	ctx.stroke();
	ctx.beginPath();
	ctx.moveTo(0.5*width+5+crosshairSize,0.5*height);
	ctx.lineTo(0.5*width+20+crosshairSize,0.5*height);
	ctx.stroke();
	ctx.beginPath();
	ctx.moveTo(0.5*width,0.5*height-20-crosshairSize);
	ctx.lineTo(0.5*width,0.5*height-5-crosshairSize);
	ctx.stroke();
	ctx.beginPath();
	ctx.moveTo(0.5*width,0.5*height+5+crosshairSize);
	ctx.lineTo(0.5*width,0.5*height+20+crosshairSize);
	ctx.stroke();

	// gun
	const
		gunPosition = state.getGunPostion(),
		gunPosStartX = gunPosition[0],
		gunPosStartY = gunPosition[1],
		gunWidth = gunPosition[2],
		gunHeight = gunPosition[3],
		gun = document.getElementById("gun"),
		gunWidthSource = gun.width,
		gunHeightSource = gun.height;
	if (state.isFiring) {
		const 
			muzzle = document.getElementById("muzzle"),
			muzzleWidthSource = muzzle.width,
			muzzleHeightSource = muzzle.height,
			muzzleHeight = 0.2 * gunWidth,
			muzzleWidth = muzzleHeight,
			muzzleCenterX = gunPosStartX + gunWidth * (5.4 / 20.7),
			muzzleCenterY = gunPosStartY + gunHeight * (1.7 / 13.2),
			muzzlePosStartX = 0 - 0.5 * muzzleWidth, /* after translate, muzzle center is 0,0 */
			muzzlePosStartY = 0 - 0.5 * muzzleHeight;
			// draw muzzle
		ctx.translate(muzzleCenterX, muzzleCenterY);
		ctx.rotate(state.muzzelRotate);
		ctx.drawImage(muzzle, 0, 0, muzzleWidthSource, muzzleHeightSource, muzzlePosStartX, muzzlePosStartY, muzzleWidth, muzzleHeight);
		ctx.rotate(-state.muzzelRotate);
		ctx.translate(-muzzleCenterX, -muzzleCenterY);
		// draw crater
		ctx.fillStyle = state.bulletHitConfirmed ? 'rgb(255,0,0)' : 'rgb(0,0,0)';
		ctx.beginPath();
		ctx.arc(state.bulletHitX, state.bulletHitY, 2, 0, 2 * Math.PI);
		ctx.fill();
	}
	ctx.drawImage(gun, 0, 0, gunWidthSource, gunHeightSource, gunPosStartX, gunPosStartY, gunWidth, gunHeight);
	// empty bullet
	const 
		emptyBullet = document.getElementById("emptyBullet"),
		emptyBulletWidth = emptyBullet.width,
		emptyBulletHeight = emptyBullet.height,
		bulletDimension = gunWidth * 0.05;
	state.emptyBullets.map((i) => {
		ctx.drawImage(emptyBullet, 0, 0, emptyBulletWidth, emptyBulletHeight, i[0], i[1], bulletDimension, bulletDimension);
	});

	// reloading text
	const flasingText = (messageString) => {
		ctx.font = "36px csFont";
		if (state.canvasCenterTextOpacity >= 0.5 && state.canvasCenterTextOpacity <= 1) {
			state.canvasCenterTextOpacity = state.canvasCenterTextOpacity + 0.1 * state.canvasCenterTextOpacitySign
		}
		if (state.canvasCenterTextOpacity < 0.5) {
			state.canvasCenterTextOpacity = 0.5;
			state.canvasCenterTextOpacitySign = 1;
		} else if (state.canvasCenterTextOpacity > 1) {
			state.canvasCenterTextOpacity = 1;
			state.canvasCenterTextOpacitySign = -1;
		}
		ctx.fillStyle = "rgba(255, 0, 0, " + state.canvasCenterTextOpacity + ")";
		ctx.textAlign = "center";
		ctx.fillText(messageString, width * 0.5, height * 0.6); 
	};
	if (state.isReloading) {
		flasingText('RELOADING')
	};
	// no ammo text
	if (state.isShowingNoAmmoText) {
		flasingText('RAN OUT OF AMMO')
	};
	// latency text
	if (state.isDisplayingLatency) {
		ctx.font = "300 10px Roboto";
		ctx.fillStyle = "rgb(0, 0, 0)";
		ctx.textAlign = "right";
		ctx.fillText('ping: ' + state.latency + ' ms', width, 10); 
	};
	// damage indicator
	if(state.damageIndicator.length !== 0) {
		//
		const otherPlayerAngleArray = [];
		const otherPlayersArray = this.otherPlayers.slice();
		otherPlayersArray.map(obj => {
			if (state.damageIndicator.indexOf(obj.playerId) !== -1) {
				otherPlayerAngleArray.push(obj.anotherPlayersAngleToMainPlayer)
			}
		})
		let mainPlayerFacing = this.mainPlayer.alpha;
		mainPlayerFacing = CONST.remapAngleToZeroToTwoPI(mainPlayerFacing);
		let diff = mainPlayerFacing - otherPlayerAngleArray[0];
		diff = CONST.remapAngleToZeroToTwoPI(diff);

		const calcDirection = (diff, fov) => {
			const twoPI = Math.PI * 2;
			const halfFov = 0.5 * fov;
			if ((-halfFov + twoPI < diff && diff <= twoPI) || (0 <= diff && diff <= halfFov)) {
				return 'front'
			} else if (halfFov < diff && diff <= 0.375 * twoPI) {
				return 'left'
			} else if (0.375 * twoPI < diff && diff <= 0.625 * twoPI) {
				return 'back'
			} else if (0.625 * twoPI < diff && diff <= -halfFov + twoPI) {
				return 'right'
			}
		}

		otherPlayerAngleArray.map(otherPlayerAngle => {
			let diff = mainPlayerFacing - otherPlayerAngle;
			diff = CONST.remapAngleToZeroToTwoPI(diff);
			const obj = {
				direction: calcDirection(diff, this.fov),
				date: new Date()
			};
			this.drawDamageIndicatorArray.push(obj)
		});
		//
		state.damageIndicator = [];
	};
	if (this.drawDamageIndicatorArray.length !== 0) {
		ctx.strokeStyle = 'rgba(255,0,0,0.3)';
		ctx.lineWidth = 0.05 * height;
		this.drawDamageIndicatorArray.map(obj => {
			const direction = obj.direction;
			const twoPI = Math.PI * 2;
			ctx.beginPath();
			if (direction === 'front') {
				start = -0.375 * twoPI;
			} else if (direction === 'right') {
				start = -0.125 * twoPI;
			} else if (direction === 'back') {
				start = 0.125 * twoPI;
			} else if (direction === 'left') {
				start = 0.375 * twoPI;
			} 
			end = start + 0.25 * twoPI;
			ctx.arc(0.5 * width, 0.5 * height, 0.2 * height, start, end);
			ctx.stroke();	
		});
		ctx.lineWidth = 1;

		// filter out old damage indicator
		const now = new Date();
		this.drawDamageIndicatorArray = this.drawDamageIndicatorArray.filter(obj => {
			const start = new Date(obj.date);
			return now - start < 1000
		});
	}
	// Minimap
	this.drawMinimap();
}
Game.prototype.updateOtherPlayers = function() {
	const array = [];
	state.playersArray.map(obj => {
		if (obj.playerId !== state.playerId) array.push(obj)
	})
	this.otherPlayers = array;
	// clear hit zone
	state.hitZone = [];
// modify the object, add property anotherPlayersAngleToMainPlayer, isInSight, distance
	const appendProperties = (otherPlayer) => {
			const 
				x1 = this.mainPlayer.x,
				y1 = this.mainPlayer.y,
				x2 = otherPlayer.x,
				y2 = otherPlayer.y,
				dx = x2 - x1,
				dy = y2 - y1,
				z = Math.pow(dx*dx + dy*dy, 0.5),
				twoPI = Math.PI * 2;
				rayAngleArray = this.rayAngleArray.slice(),
				width = CONST.getWindowWidth(),
				height = CONST.getWindowHeight(),
				jumpHeight = otherPlayer.accumulatedJumpHeight,
				remapAngleToZeroToTwoPI = CONST.remapAngleToZeroToTwoPI;
			let anotherPlayersAngleToMainPlayer;
			// dy is reversed in canvas cordinate, and our 0 deg is x-positive !!
			if (dx === 0 && dy === 0) {
				anotherPlayersAngleToMainPlayer = 0;
			} else if (dx === 0) {
				if (dy > 0) {
					anotherPlayersAngleToMainPlayer = 0.25 * twoPI
				} else if (dy < 0) {
					anotherPlayersAngleToMainPlayer = 0.75 * twoPI
				}
			} else if (dy === 0) {
				if (dx > 0) {
					anotherPlayersAngleToMainPlayer = 0
				} else if (dx < 0){
					anotherPlayersAngleToMainPlayer = 0.5 * twoPI
				}
			} else if (dx > 0 && dy > 0) {
				anotherPlayersAngleToMainPlayer = Math.atan(dy / dx);
			} else if (dx < 0 && dy > 0) {
				anotherPlayersAngleToMainPlayer = twoPI * 0.5 - Math.atan(dy / -dx);
			} else if (dx < 0 && dy < 0) {
				anotherPlayersAngleToMainPlayer = Math.atan(-dy / -dx) + twoPI * 0.5;
			} else if (dx > 0 && dy < 0) {
				anotherPlayersAngleToMainPlayer = twoPI - Math.atan(-dy / dx);
			} 
			anotherPlayersAngleToMainPlayer = remapAngleToZeroToTwoPI(anotherPlayersAngleToMainPlayer);

			function checkIfAnotherPlayerIsInSight(sightStartAngle, sightEndAngle, fov, anotherPlayersAngleToMainPlayer) {
				const end = remapAngleToZeroToTwoPI(sightEndAngle);
				let start = remapAngleToZeroToTwoPI(sightStartAngle); 
				//console.log(start * 360 / Math.PI / 2, end * 360 / Math.PI / 2, anotherPlayersAngleToMainPlayer* 360 / Math.PI / 2)
				if (end < fov) {
					if ((start < anotherPlayersAngleToMainPlayer && anotherPlayersAngleToMainPlayer < Math.PI * 2) || (0 < anotherPlayersAngleToMainPlayer && anotherPlayersAngleToMainPlayer < end)) {
						return true
					} else {
						return false
					}
				} else {
					if (start < anotherPlayersAngleToMainPlayer && anotherPlayersAngleToMainPlayer < end) {
						return true;
					} else {
						return false;
					}
				}
			}
		const isOtherPlayerInSight = checkIfAnotherPlayerIsInSight(rayAngleArray[0], rayAngleArray[rayAngleArray.length - 1], this.fov, anotherPlayersAngleToMainPlayer);

		otherPlayer.isInSight = isOtherPlayerInSight;
		otherPlayer.anotherPlayersAngleToMainPlayer = anotherPlayersAngleToMainPlayer;
		otherPlayer.distance = z;
	}
	//
	this.otherPlayers.map(obj => {
		appendProperties(obj)
	});
	// sort, draw from far to close
	this.otherPlayers.sort((a, b) => b.distance - a.distance);
}
Game.prototype.drawOtherPlayers = function(otherPlayer, anotherPlayersAngleToMainPlayer, z, screenWidth, screenHeight) {
	const 
		otherPlayerId = otherPlayer.playerId,
		playerMaxWidth = 0.3 * CONST.getWindowWidth(),
		playerMaxHeight = playerMaxWidth * 1.5,
		//distance = z * Math.cos(anotherPlayersAngleToMainPlayer),
		distance = z,
		playerCurrentWidth = Math.min((3 * playerMaxWidth / z) * 0.8, playerMaxWidth),
		playerCurrentHeight = Math.min((3 * playerMaxHeight / z) * 0.8, playerMaxHeight),
		playerCurrentJumpHeight = Math.min(6 * otherPlayer.accumulatedJumpHeight / z, otherPlayer.accumulatedJumpHeight);

	const remapAngleToZeroToTwoPI = CONST.remapAngleToZeroToTwoPI;
	const end = remapAngleToZeroToTwoPI(rayAngleArray[rayAngleArray.length - 1]);
	let start = remapAngleToZeroToTwoPI(rayAngleArray[0]); 

	if (anotherPlayersAngleToMainPlayer < start) {
		// this function is called when another player is garanteed in sight
		anotherPlayersAngleToMainPlayer += Math.PI * 2
	}
	otherPlayerPosOnScreen = Math.floor((anotherPlayersAngleToMainPlayer - start) / this.dAlpha);
	const wallDistAtThisPos = this.wallDistArrayBeforeFishEyeCorrection[otherPlayerPosOnScreen];
	if (z < wallDistAtThisPos) {
		// check if another player is blocked by wall is HERE!!
		// draw other player if insight
		const ctx = document.getElementById('mainCanvas').getContext('2d');
		const soilderEl = document.getElementById('soilder');
		const 
			drawX = (otherPlayerPosOnScreen * param.resolution - playerCurrentWidth / 2),
			drawY = 0.5 * (screenHeight - playerCurrentHeight) + 0.2 * playerCurrentHeight + state.accumulatedJumpHeight - playerCurrentJumpHeight,
			drawWidth = playerCurrentWidth,
			drawHeight = playerCurrentHeight;
		//ctx.fillStyle = otherPlayer.isRespawning ? 'rgba(0, 255, 0, 0.3)' : 'rgba(0, 255, 0, 1)';
		//ctx.beginPath();
		//ctx.fillRect(drawX, drawY, drawWidth, drawHeight);
		//ctx.fill();
		ctx.globalAlpha = otherPlayer.isRespawning ? 0.5 : 1;
		ctx.drawImage(soilderEl, 0, 0, soilderEl.width, soilderEl.height, drawX, drawY, drawWidth, drawHeight);
		// player shadow
		// const gradient = ctx.createLinearGradient(drawX, drawY, drawX + 200,drawY +200);
		// gradient.addColorStop(0, 'rgba(0,0,0,0.2)');
		// gradient.addColorStop(.5, 'rgba(0,0,0,1)');
		// gradient.addColorStop(1, 'rgba(0,0,0,0.2)');
		// ctx.fillStyle = gradient;
		// ctx.beginPath();
		// ctx.ellipse(drawX + 0.5 * drawWidth, drawY + drawHeight, 0.4 * drawWidth, 0.1 * drawWidth, 0, 0, 2 * Math.PI);
		// ctx.fill();
		ctx.globalAlpha = 1;
		// other player's id
		const fontSize = Math.min(18, 8 + 20/z);
		ctx.font = '500 ' + fontSize + 'px Roboto';
		ctx.fillStyle = "rgb(255, 0, 0)";
		ctx.textAlign = "center";
		ctx.fillText(otherPlayerId, drawX + 0.5 * drawWidth, drawY - 10); 
		// update hitZone
		if (!otherPlayer.isRespawning) {
			state.hitZone.push([otherPlayerId, drawX, drawY, drawWidth, drawHeight]);
		}
	}
}
Game.prototype.drawMinimap = function() {
	// variables
	const 
		ctx = document.getElementById('mainCanvas').getContext('2d'),
		miniMapMargin /* eg: top =left = 10px */= this.miniMapMargin,
		mapGrid = this.mapGrid.slice(),
		mapGridSize /* it's a square */ = mapGrid.length,
		miniMapSize /* it's a square */ = this.miniMapSize,
	 	pixel /* unit pixel for one grid, eg: 200/40=5px */ = miniMapSize / mapGridSize,
	 	rayAngleArray = this.rayAngleArray.slice(),
	 	wallDistArray = this.wallDistArrayBeforeFishEyeCorrection.slice(),
	 	playerXOnMinimap = this.mainPlayer.x * pixel + miniMapMargin,
	 	playerYOnMinimap = this.mainPlayer.y * pixel + miniMapMargin,
	 	isTogglingMiniMap /* 1: enlarging, 0: false, -1: shrinking */ = state.isTogglingMiniMap,
		miniMapSizeInNextFrame = miniMapSize + isTogglingMiniMap * this.miniMapToggleSpeed;

	// toggling minimap
	if (isTogglingMiniMap) {
		// indeed is toggling
		if (miniMapSizeInNextFrame >= this.miniMapSizeMax || miniMapSizeInNextFrame <= this.miniMapSizeMin) {
			// last frame
			this.miniMapSize = isTogglingMiniMap === 1 ? this.miniMapSizeMax : this.miniMapSizeMin
		} else {
			this.miniMapSize = miniMapSizeInNextFrame
		}
	}

	// wall
	for (let y=0; y<mapGridSize; y++) {
		for (let x=0; x<mapGridSize; x++){
			if (mapGrid[y][x]) {
				ctx.fillStyle = "rgba(0,150,0,0.5)";
				ctx.fillRect(x * pixel + miniMapMargin, y * pixel + miniMapMargin, pixel, pixel);
			}
		}
	}
	// player
	ctx.fillStyle = "red";
	ctx.beginPath();
	ctx.arc(playerXOnMinimap, playerYOnMinimap, miniMapSize / 100, 0 , 2 * Math.PI);
	ctx.fill();
	// rays
	rayAngleArray.map((i, index) => {
		const thisRayLength = wallDistArray[index];
		ctx.strokeStyle = "rgba(0,255,0,0.01)";
		ctx.beginPath();
		ctx.moveTo(playerXOnMinimap, playerYOnMinimap);
		ctx.lineTo(playerXOnMinimap + pixel * thisRayLength * Math.cos(i), playerYOnMinimap + pixel * thisRayLength * Math.sin(i));
		ctx.stroke();
	})
	// direction pointer
	ctx.strokeStyle = "black";
	ctx.beginPath();
	ctx.moveTo(playerXOnMinimap, playerYOnMinimap);
	ctx.lineTo(playerXOnMinimap + pixel * Math.cos(this.mainPlayer.alpha), playerYOnMinimap + pixel * Math.sin(this.mainPlayer.alpha));
	ctx.stroke();
	// grid
	for (let i = 0; i <= mapGridSize; i++) {
		const 
			start = i * pixel + miniMapMargin,
			end = mapGridSize * pixel + miniMapMargin;
		ctx.strokeStyle = "rgba(0,150,0,0.1)";
		ctx.beginPath();
		ctx.moveTo(miniMapMargin, start);
		ctx.lineTo(end, start);
		ctx.moveTo(start, miniMapMargin);
		ctx.lineTo(start, end);
		ctx.stroke();
	}
}
Game.prototype.attachEventListeners = function() {
	const player = this.mainPlayer;
	document.addEventListener('keydown', function(e) {
					switch(e.keyCode){
						case 65:
							player.counterClockwise = true;
							break;
						case 87:
							player.forward = true;
							break;
						case 68:
							player.clockwise = true;
							break;
						case 83:
							player.backward = true;
							break;
						case 32:
							if(!state.accumulatedJumpHeight) state.currentJumpVelocity = param.getInitialJumpVelocity();
							break;
						case 77:
							const isTogglingMiniMap = state.isTogglingMiniMap;
							state.isTogglingMiniMap = !isTogglingMiniMap ?
														1 :
														isTogglingMiniMap === 1 ?
														-1 :
														1;

							break;
						case 13:
							if(!state.isFireRequested) state.isFireRequested = true;
							break;
						case 82:
							if(!state.isReloadRequested) state.isReloadRequested = true;
							break;
					}
})
document.addEventListener('keyup', function(e) {
					switch(e.keyCode){
						case 65:
							player.counterClockwise = false;
							break;
						case 87:
							player.forward = false;
							break;
						case 68:
							player.clockwise = false;
							break;
						case 83:
							player.backward = false;
							break;
						case 13:
							state.isFireRequested = false;
							break;	
					}
})
}
Game.prototype.respawnFrame = function() {
	const now = new Date();
	const timeDiff = now - new Date(this.deathTimeStamp);
	if (timeDiff > 5000) {
		this.mainPlayer.respawn();
	};
	// 
	if (state.isConnectedToServer) {
		serverConnection.upLinkUpdatePosition();
	};

	// animation
	if (this.respawnFramethrottler % 4 === 0) {
		const ctx = document.getElementById('mainCanvas').getContext('2d');
		const width = CONST.getWindowWidth();
		const height = CONST.getWindowHeight();
		if (timeDiff < 2500) {
			ctx.fillStyle = 'rgba(0,0,0,0.1)';
			ctx.fillRect(0, 0, width, height);
			ctx.fill();
			//
			ctx.font = '700 36px Roboto';
			ctx.fillStyle = "rgb(255, 255, 255)";
			ctx.textAlign = "center";
			ctx.fillText('RESPAWNING', 0.5 * width, 0.5 * height); 
		} else {
			ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
			ctx.fillRect(0, 0, width, height);
			ctx.fill();
			//
			ctx.font = '700 36px Roboto';
			ctx.fillStyle = "rgb(0, 0, 0)";
			ctx.textAlign = "center";
			ctx.fillText('HOLD ON', 0.5 * width, 0.5 * height); 
		}
	}
	this.respawnFramethrottler++


	//
	if (state.isRespawning) {
		requestAnimationFrame(this.respawnFrame);
	} else {
		this.respawnFramethrottler = 1;
		requestAnimationFrame(this.frame);
	}
}
Game.prototype.frame = function() {
	this.mainPlayer.move();
	if (state.isConnectedToServer) {
		serverConnection.upLinkUpdatePosition();
		this.updateOtherPlayers();
	}
	this.ray();
	this.drawFrame();

	if (!state.isRespawning) {
		requestAnimationFrame(this.frame);
	} else {
		// state.isRespawning changed in serverconnection handledownlinkhitby
		this.deathTimeStamp = new Date();
		requestAnimationFrame(this.respawnFrame);
	}
}
Game.prototype.play = function() {
	game.initiateCanvas();
	game.createMainPlayer();
	game.attachEventListeners();
	serverConnection.initiateConnection();

	this.respawnFrame = this.respawnFrame.bind(this);
	this.frame = this.frame.bind(this);
	requestAnimationFrame(this.frame);
}
function ServerConnection() {
	this.lastPing;
	this.ws;
}
ServerConnection.prototype.initiateConnection = function() {
	const HOST = location.origin.replace(/^http/, 'ws');
	const ws = new WebSocket(HOST);
	this.ws = ws;

	ws.onopen = function() {
		state.updateServerMessage('Connected to the server');
		const requestJoinGame = {
			what: 'upLinkRequestJoinGame',
		};
		ws.send(JSON.stringify(requestJoinGame));
	};

	ws.onmessage = (e) => {
		const received = JSON.parse(e.data);
		if (received.what === 'downLinkUpdatePosition') {
			this.handleDownLinkUpdatePosition(received)
		} else if (received.what === 'serverMessage') {
			// serverMessage that need to be post to serverMessageComponent
			state.updateServerMessage(received.payload);
		} else if (received.what === 'downLinkRequestJoinGame') {
			// set _id for this player
			this.handleDownLinkRequestJoinGame(received)
		};
	}

	ws.onerror = (e) => console.log(e);
	ws.onclose = () => {
		state.updateServerMessage('Connection lost. Please refresh the page to reconnect.');
		state.isConnectedToServer = false;
	}
}
ServerConnection.prototype.handleDownLinkRequestJoinGame = function(received) {
	const myID = received.payload;
	state.playerId = myID;
	state.isConnectedToServer = true;
}
ServerConnection.prototype.upLinkUpdatePosition = function() {
	const payload = {
		playerId: state.playerId,
		x: game.mainPlayer.x,
		y: game.mainPlayer.y,
		accumulatedJumpHeight: state.accumulatedJumpHeight,
		healthPoint: state.healthPoint,
		death: state.death,
		latency: state.latency,
		timeSent: new Date(),
		isRespawning: (state.isRepawnProtected || state.isRespawning) ? true : false,
		hitPlayerArray: state.hitPlayerArray
	};
	if (state.killedBy) {
		payload.killedBy = state.killedBy
	}
	const data = {
		what: 'upLinkUpdatePosition',
		payload: payload,
		playerId: state.playerId,
	};
	this.ws.send(JSON.stringify(data));

	//reset after sent
	state.hitPlayerArray = [];
	state.killedBy = null;
}
ServerConnection.prototype.handleDownLinkUpdatePosition = function(received) {
	//console.log(received);
	state.playersArray = received.payload.slice();
	//
	let mainPlayerObj = received.payload.filter((obj) => obj.playerId === state.playerId);
	mainPlayerObj = mainPlayerObj[0];
	// calc latency
	const now = new Date();
	const latency = Math.floor((now - new Date(mainPlayerObj.timeSent)) / 2);
	state.latency = latency;
	// calc damage
	if (mainPlayerObj.hitBy && !state.isRespawning && !state.isRepawnProtected) {
		if (mainPlayerObj.hitBy.length !== 0) {
			for (let i=0; i<mainPlayerObj.hitBy.length; i++) {
				const damage = Math.floor(Math.random() * 10 + 5);
				const hpAfterDamage = state.healthPoint - damage;
				if (hpAfterDamage <= 0) {
					state.death++;
					state.isRespawning = true;
					state.healthPoint = 0;
					state.killedBy = mainPlayerObj.hitBy[i];
					state.updateServerMessage('You were killed by ' + mainPlayerObj.hitBy[i]);
					const hpEl = document.getElementById('playerStatusHealthPoint');
					hpEl.innerHTML = state.healthPoint;
					//
					setTimeout(() => {
						state.damageIndicator = [];
						game.drawDamageIndicatorArray = [];
					}, 1000);
					break;
				} else {
					state.damageIndicator.push(mainPlayerObj.hitBy[i]);
					state.healthPoint = hpAfterDamage;
					const hpEl = document.getElementById('playerStatusHealthPoint');
					hpEl.innerHTML = state.healthPoint;
				}
			}
		}
	}
	// update info related to this player
	state.kill = mainPlayerObj.kill;
	if (mainPlayerObj.killerOf) {
		state.updateServerMessage('You killed ' + mainPlayerObj.killerOf);
	}
}



function Loading() {
	this.loaded = 0;
	this.total = 1;
	this.isLoaded /* count */= 0;
}
Loading.prototype.sendRequest = function() {
	// this will also initiate CONST.assetsCount, which will be used in this.drawLoadingPage
	const urlObj = CONST.getAssetsUrlObj();

	function appendImg(url, elId) {
		const div = document.createElement('div');
		div.style.display = 'none';
		const img = document.createElement('img');
		img.id = elId;
		img.src = url;
		div.appendChild(img);
		document.getElementById('root').appendChild(div);
	}
	const loadImgThenAppendToDom = (url, elId) => {
		const xml = new XMLHttpRequest();
		let 
			thisTotalAddedToSumTotal = false,
			loaded = 0;

		xml.open('GET', url, true);
		xml.onprogress = (e) => {
			const loadedIncrement = e.loaded - loaded;
			this.loaded += loadedIncrement;
			loaded = e.loaded;
			// add total only on first time
			if (!thisTotalAddedToSumTotal) {
				this.total += e.total;
				thisTotalAddedToSumTotal = true;
			}
		};
		xml.onload = () => {
			appendImg(url, elId);
			this.isLoaded += 1;
		}
		xml.send();
	};

	for (let key in urlObj) {
		if (urlObj.hasOwnProperty(key)) {
			loadImgThenAppendToDom(urlObj[key], key)
		}
	}
}
Loading.prototype.drawLoadingPage = function() {
	const 
		rootDiv = document.getElementById('root'),
		width = CONST.getWindowWidth(),
		height = CONST.getWindowHeight(),
		centerX = 0.5 * width,
		centerY = 0.5 * height,
		radius = Math.pow(centerX * centerX + centerY * centerY, 0.5),
		PI = Math.PI;
		angleInOneFrame = PI * 2 / 120,
		startingAngle = 0 - PI * 0.5,
		loadingCanvas = `<canvas id="loadingCanvas" width=${width} height=${height}>Your Browser Does Not Support Html5 Canvas</canvas>`, 
		loadingMessage = 
			'<div class="loading-wrapper" id="loading-wrapper">' +
				'<p>Loading <span id="loadingPercentage">0</span>%<p>' +
			'</div>';
	rootDiv.innerHTML = loadingCanvas + loadingMessage;
	const 
		ctx = document.getElementById('loadingCanvas').getContext('2d'),
		wrapper = document.getElementById('loading-wrapper'),
		loadingPercentageSpan = document.getElementById('loadingPercentage');

	let 
		endingAngle = startingAngle,
		displayingPercentage = 0,
		textColorChangedToWhite = false;
	let frame = () => {
		const 
			loadingPercentage = Math.ceil((this.loaded / this.total) * 100),
			canvasPercentage = 100 * ((endingAngle - startingAngle) / (PI * 2));

		// update text
		if (displayingPercentage + 1 <= loadingPercentage) {
			displayingPercentage++;
			loadingPercentageSpan.innerHTML = displayingPercentage;
		}

		// change text color to white once loaded > 50%
		if (displayingPercentage > 50 && !textColorChangedToWhite) wrapper.className = 'loading-wrapper white-text';

		// canvas animation
		if (canvasPercentage < loadingPercentage) {
			ctx.clearRect(0, 0, width, height);
			ctx.beginPath();
			ctx.fillStyle = 'rgb(0, 172, 237)';
			ctx.moveTo(centerX, centerY)
			ctx.arc(centerX, centerY, radius, startingAngle, endingAngle += angleInOneFrame);
			ctx.fill();
		}

		if (canvasPercentage < 100 || this.isLoaded !== CONST.assetsCount) {
			// if the true loading speed is slower (slow 3g) than canvas animation epr frame speed, finishloading will be called before img append to DOM, therefore check this.isLoaded
			requestAnimationFrame(frame)
		} else {
			this.finishLoading()
		}
	}
	requestAnimationFrame(frame);
}
Loading.prototype.finishLoading = function() {
	game.play();
	const 
		loadingCanvas = document.getElementById('loadingCanvas'),
		loadingText = document.getElementById('loading-wrapper');
	loadingCanvas.style.transition = '2s';
	loadingCanvas.style.transitionDelay = '0.5s';
	loadingCanvas.style.opacity = '0';
	loadingText.style.transition = '2s';
	loadingText.style.transitionDelay = '0.5s';
	loadingText.style.opacity = '0';

	setTimeout(() => {
		loadingCanvas.parentNode.removeChild(loadingCanvas);
		loadingText.parentNode.removeChild(loadingText);
	}, 3000);
}

function InstructionComponent() {
	this.component;
	this.isDisplaying = true;
}
InstructionComponent.prototype.mountComponent = function() {
	const rootDiv = document.getElementById('root');
	const instructionComponent = document.createElement('div');
	instructionComponent.id = 'instructionComponent';
	instructionComponent.innerHTML = 
			'<h1>cs_assault.map</h1>' +
				'<ul>' +
					'<li>I: Open / close this window</li>' +
					'<li>W: Move Forward</li>' +
					'<li>S: Move Back</li>' +
					'<li>A: Turn Left</li>' +
					'<li>D: Turn Right</li>' +
					'<li>R: Reload</li>' +
					'<li>M: Toggle Map Zooming</li>' +
					'<li>Enter: Fire</li>' +
					'<li>Space: Jump</li>' +
					'<li>Tab: Score Board</li>' +
				'</ul>' +
			'<h1>Many thanks to these tutorials:</h1>' +
				'<ul>' +
					'<li><a href="http://www.playfuljs.com/a-first-person-engine-in-265-lines/" target="_blank">PlayfulJS.com</a></li>' +
					'<li><a href="http://permadi.com/1996/05/ray-casting-tutorial-table-of-contents/" target="_blank">Permadi.com</a></li>' +
					'<li><a href="http://lodev.org/cgtutor/raycasting.html" target="_blank">Lodev.org</a></li>' +
				'</ul>' +
			'<h2><a href="https://www.xiaoxihome.com" target="_blank"><span>&copy; XIAOXIHOME.COM 2017~2018</span></a><h2>';
	rootDiv.appendChild(instructionComponent);
	this.component = instructionComponent;
	this.attachEventListener();
	this.toggleDisplay();
}
InstructionComponent.prototype.attachEventListener = function() {
	document.addEventListener('keydown', (e) => {
		if (e.keyCode === 73) {
			// button I
			this.toggleDisplay()
		}
	});
}
InstructionComponent.prototype.toggleDisplay = function() {
	if (this.isDisplaying) {
		this.component.style.opacity = 0;
		this.component.style.visibility = 'hidden';
	} else {
		this.component.style.opacity = 1;
		this.component.style.visibility = 'visible';
	}
	this.isDisplaying = !this.isDisplaying;
}
function ToolBarComponent() {
	const createDiv = (id) => {
		const div = document.createElement('div');
		div.id = id;
		return div;
	}
	const settingItems = [];
	const createSettingItem = (settingItemsArray, text, statePropertyString, initiateIsON) => {
		const number = settingItemsArray.length;
		const item = createDiv('settingDropdownItem' + number);
		item.className = 'settingDropdownItem';
		const onHandler = () => {
			item.innerHTML = '<span>' + text + ' <i class="fas fa-toggle-on" style="color: green; font-size: 24px; top: .125em; position: relative""></i></span>';
			state[statePropertyString] = true;
		};
		const offHandler = () => {
			item.innerHTML = '<span>' + text + ' <i class="fas fa-toggle-off" style="color: rgba(0,0,0,0.5); font-size: 24px; top: .125em; position: relative"></i></span>';
			state[statePropertyString] = false;
		}
		initiateIsON ? onHandler() : offHandler();
		item.onclick = (e) => {
			e.stopPropagation();
			state[statePropertyString] ? offHandler() : onHandler();
		};
		settingItemsArray.push(item);
	};
	const 
		toolBarComponent = createDiv('toolBarComponent'),
		info = createDiv('info'),
		setting = createDiv('setting'),
		settingDropdown = createDiv('settingDropdown');
	createSettingItem(settingItems, 'Lower graphic quality', 'isLowerGraphicQuality', false);
	createSettingItem(settingItems, 'Display latency', 'isDisplayingLatency', true);
	info.innerHTML = '<span><i class="fas fa-info-circle"></i></span>';
	setting.innerHTML = '<span><i class="fas fa-cog"></i></span>';

	info.onclick = () => {
		const event = new Event('keydown');
		event.keyCode = 73;
		document.dispatchEvent(event);
	}
	setting.onclick = () => {
		this.isSettingDropdownActive ? this.closeSettingDropdown() : this.openSettingDropdown();
	}
	settingDropdown.onmouseleave = () => {
		this.closeSettingDropdown()
	}

	setting.appendChild(settingDropdown);
	toolBarComponent.appendChild(info);
	toolBarComponent.appendChild(setting);
	settingItems.map(item => settingDropdown.appendChild(item));

	this.component = toolBarComponent;
	this.settingDropdownComponent = settingDropdown;
	this.isSettingDropdownActive = false;
}
ToolBarComponent.prototype.mountComponent = function() {
	const rootDiv = document.getElementById('root');
	rootDiv.appendChild(this.component);
}
ToolBarComponent.prototype.closeSettingDropdown = function() {
	if (this.isSettingDropdownActive) {
		const dropdown = this.settingDropdownComponent;
		dropdown.style.opacity = 0;
		dropdown.style.visibility = 'hidden'
		this.isSettingDropdownActive = false;
	}
}
ToolBarComponent.prototype.openSettingDropdown = function() {
	if (!this.isSettingDropdownActive) {
		const dropdown = this.settingDropdownComponent;
		dropdown.style.opacity = 1;
		dropdown.style.visibility = 'visible'
		this.isSettingDropdownActive = true;
	}
}

function PlayerStatusComponent() {
	this.component;
}
PlayerStatusComponent.prototype.mountComponent = function() {
	const rootDiv = document.getElementById('root');
	const playerStatusComponent = document.createElement('div');
	playerStatusComponent.id = 'playerStatusComponent';
	playerStatusComponent.innerHTML = 
			'<div class="playerStatusGroupWrapper">' +
				'<div class="playerStatusIcon" style="position: relative; top: -0.1em;">' +
					'<i class="fas fa-times-circle"></i>' +
				'</div>' +
				'<div class="playerStatusValue">' +
					'<span id="playerStatusHealthPoint">' + state.healthPoint + '</span>' +
				'</div>' +
			'</div>' +
			'<div class="playerStatusGroupWrapper">' +
				'<div class="playerStatusIcon" style="position: relative; top: -0.4em;">' +
					'<i class="fas fa-joint"></i>' +
				'</div>' +
				'<div class="playerStatusValue">' +
					'<span id="plaerStatusCurrentMagzine">' + state.currentMagzine + '</span>' + '|' + '<span id="plaerStatusTotalMagzine">' + state.totalMagzine + '</span>' +
				'</div>' +
			'</div>';
	rootDiv.appendChild(playerStatusComponent);
	this.component = playerStatusComponent;
}

function ServerMessageComponent() {
	this.component;
	this.itemWrapperClass = 'serverMessageItemWrapper';
}
ServerMessageComponent.prototype.mountComponent = function() {
	const rootDiv = document.getElementById('root');
	const serverMessageComponent = document.createElement('div');
	serverMessageComponent.id = 'serverMessageComponent';
	rootDiv.appendChild(serverMessageComponent);
	this.component = serverMessageComponent;
}

function ScoreBoardComponent() {
	this.component;
	this.isDisplaying = false;
	this.rowClassName = 'scoreBoardRow';
	this.rowTitleClassName = 'scoreBoardRowTitle scoreBoardRow';
	this.rowHighlightClassName = 'scoreBoardRow scoreBoardRowHighlight';
	this.rowItemClassName = 'scoreBoardRowItem';

	this.timeInterval;
}
ScoreBoardComponent.prototype.mountComponent = function() {
	const rootDiv = document.getElementById('root');
	const scoreBoardComponent = document.createElement('div');
	scoreBoardComponent.id = 'scoreBoardComponent';
	rootDiv.appendChild(scoreBoardComponent);
	this.component = scoreBoardComponent;
	this.attachEventListener();
}
ScoreBoardComponent.prototype.attachEventListener = function() {
	document.addEventListener('keydown', (e) => {
		if (e.keyCode === 9) {
			// button Tab
			e.preventDefault();
			this.toggleDisplay();
		}
	});
}
ScoreBoardComponent.prototype.toggleDisplay = function() {
	if (this.isDisplaying) {
		this.isDisplaying = false;
		clearInterval(this.timeInterval);
		this.timeout = null;
		this.component.style.opacity = 0;
		this.component.style.visibility = 'hidden';
	} else {
		this.isDisplaying = true;
		this.updateData();
		this.timeInterval = setInterval(() => this.updateData(), 1000);
		this.component.style.opacity = 1;
		this.component.style.visibility = 'visible';
	}
}
ScoreBoardComponent.prototype.updateData = function() {
	if (this.isDisplaying) {
		// sort state.playersArray
		const playersArray = state.playersArray.slice();
		playersArray.sort((a, b) => b.kill - a.kill)

		// components
		const playerId = state.playerId;

		const createRow = (isHightLighted) => {
			const row = document.createElement('div');
			row.className = isHightLighted ? this.rowHighlightClassName : this.rowClassName;
			return row
		}
		const createRowItem = (itemContent) => {
			const item = document.createElement('div');
			item.className = this.rowItemClassName;
			item.innerHTML = itemContent;
			return item
		}

		this.component.innerHTML = '';
		const title = document.createElement('div');
		title.className = this.rowTitleClassName;
		const id = createRowItem('Player ID');
		const kill = createRowItem('Kill');
		const death = createRowItem('Death');
		const latency = createRowItem('Ping');
		title.appendChild(id);
		title.appendChild(kill);
		title.appendChild(death);
		title.appendChild(latency);
		this.component.appendChild(title);

		playersArray.map(obj => {
			const row = obj.playerId === playerId ? createRow(true) : createRow(false);
			const id = createRowItem(obj.playerId);
			const kill = createRowItem(obj.kill);
			const death = createRowItem(obj.death);
			const latency = createRowItem(obj.latency + 'ms');
			row.appendChild(id);
			row.appendChild(kill);
			row.appendChild(death);
			row.appendChild(latency);
			this.component.appendChild(row);
		})
	}
}


window.onload = function() {
	const loading = new Loading();
	loading.sendRequest();
	loading.drawLoadingPage();
}



</script>
</body>
</html>