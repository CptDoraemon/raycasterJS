<!DOCTYPE html>
<head>
<title>cs_assault by Raycaster</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
<link rel="shortcut icon" href="./assets/favicon.ico">
<link href="https://fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/solid.css" integrity="sha384-r/k8YTFqmlOaqRkZuSiE9trsrDXkh07mRaoGBMoDcmA58OHILZPsk29i2BsFng1B" crossorigin="anonymous">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/fontawesome.css" integrity="sha384-4aon80D8rXCGx9ayDt85LbyUHeMWd3UiBaWliBlJ53yzm9hqN21A+o1pqoyK04h+" crossorigin="anonymous">
<style>
@font-face {
  font-family: 'csFont';
  src: URL('./assets/cs_regular.ttf') format('truetype');
}
body {
	width: 100vw;
	max-width: 100%;
	height: 100vh;
	margin: 0;
	overflow: hidden;
	font-family: 'Ubuntu', sans-serif;
}
.loading-wrapper {
	width: 300px;
	height: 200px;
	display: flex;
	flex-direction: row;
	align-items: center;
	justify-content: center;
	position: fixed;
	top: 55%;
	left: calc(50% - 150px);
	z-index: 101;
	color: black;
	transition: color 0.5s;
}
.loading-wrapper p {
	font-size: 32px;
	font-weight: bold;
	color: inherit;
}
.white-text {
	color: white !important;
}
#loadingCanvas {
	z-index: 100;
	position: fixed;
	top: 0;
	left: 0;
}
#instructionComponent {
	color: rgba(255, 255, 0, 0.8); 
	background-color: rgba(0,0,0,0.8);
	opacity: 1;
	font-family: 'csFont', monospace;
	font-size: 24px; 
	line-height: 1.2em;
	letter-spacing: 0.0625em;
	position: fixed;
	z-index: 10;
	top: 0;
	left: 0;
	display: flex;
	flex-direction: column;
	align-items: flex-start;
	justify-content: center;
	width: 60%;
	margin: 10%;
	padding: 2% 10%;
	transition: 0.3s;
}
#instructionComponent h1 {
	font-size: 48px; 
}
#instructionComponent h2 {
	/* copyright */
	position: relative;
	font-size: 16px;
	float: right;
	margin-top: 20px;
	line-height: 1em;
}
#instructionComponent ul {
	list-style: none;
	margin: 0;
}
#instructionComponent a:hover {
	color: rgb(255, 255, 255); 
	transition: 0.3s;
}
#toolBarComponent {
	position: fixed;
	top: 50px;
	right: 50px;
	z-index: 10;
	width: 100px;
	height: 50px;
	display: flex;
	flex-direction: row;
	align-items: center;
	justify-content: space-between;
}
#info, #setting {
	position: relative;
}
#info span, #setting span {
	font-size: 24px;
	color: rgb(255, 255, 255);
	transition: 0.3s;
	cursor: pointer;
	opacity: 0.5;
}
#info:hover::after, #setting:hover::after {
	width: 100%;
	position: absolute;
	top: -100%;
	left: -100%;
	font-size: 18px;
	color: white;
	font-weight: bold;
}
#info:hover::after {
	content: 'Instructions';
}
#setting:hover::after {
	content: 'Settings';
}
#settingDropdown {
	position: absolute;
	opacity: 0;
	visibility: hidden;
	right: -10px;
	top: 150%;
	width: 300px;
	background-color: white;
	border-radius: 5px;
	display: flex;
	flex-direction: column;
	align-items: center;
	justify-content: flex-start;
}
#settingDropdown::after {
	content: '';
	position: absolute;
	width: 10px;
	height: 10px;
	top: -5px;
	right: 16px;
	background-color: white;
	transform: rotate(45deg);
}
#settingDropdown span {
	color: black;
	font-weight: bold;
	font-size: 14px;
	opacity: 1;
}
#settingDropdown i {
	margin-left: 10px;
}
#info span:hover, #setting span:hover {
	opacity: 1;
	transition: 0.3s;
}
#settingDropdownItem1 {
	height: 50px;
	line-height: 50px;
	width: calc(100% - 20px);
	margin: 10px;
	display: flex;
	flex-direction: row;
	align-items: center;
	justify-content: center;
}
#settingDropdownItem1:hover {
	background-color: rgba(100,100,100,0.1);
	cursor: pointer;
}
#playerStatusComponent {
	color: rgba(255, 255, 0, 0.8); 
	font-family: 'csFont', monospace;
	letter-spacing: 0.0625em;
	position: fixed;
	left: 10px;
	bottom: 10px;
	display: flex;
	flex-direction: row;
	align-items: flex-start;
	justify-content: center;
	z-index: 10;
	font-size: 32px;
}
.playerStatusGroupWrapper {
	display: flex;
	flex-direction: row;
	align-items: center;
	justify-content: center;
	margin: 0 50px;
}
.playerStatusIcon {
	transform: rotate(45deg);
	margin: 0 10px;
}
.playerStatusValue span {
	margin: 0 5px;
}
a{
	text-decoration: none;
	display: block;
	padding: 0 5%;  
}
a:link, a:visited, a:hover, a:active{
	color: inherit;
}
a:hover {
	opacity: 1;
}
</style>
</head>
<body>
<div id='root'></div>
<script>
(function() {
	GlobalVar = function() {
		// global variables
	};
	const 
		width = window.innerWidth,
		height = window.innerHeight,
		assetsUrlObj = {
			sky: './assets/sky.jpg',
			gun: './assets/gun.png',
			muzzle: './assets/muzzle.png',
		};
	GlobalVar.prototype.getWindowWidth = function() {
		return width
	};
	GlobalVar.prototype.getWindowHeight = function(){
		return height
	};
	GlobalVar.prototype.getAssetsUrlObj = function(){
		this.assetsCount = Object.keys(assetsUrlObj).length;
		return assetsUrlObj
	}
})();
const CONST = new GlobalVar();

(function() {
	// parameters
	Param = function() {
		this.resolution /* it will be divided by window width */ = 1;
		this.resolutionHigh = 1;
		this.resolutionLow = 5;
		//
		this.healthPointMax = 100;
		this.currentMagzineMax = 30;
		this.totalMagzineMax = 240;
		//
		this.recoilStaticMax = 10;
		this.recoilMovingMax = 100;
		this.gunPositionOffsetMax = 10;
		this.gunPositionFiringOffsetMax = 30;
	};
	const mapGrid = 
	[
		[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 3, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
		[1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1],
		[1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1],
		[1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1],
		[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]   
	];

	const wallColorArray /* [wallType][HitDirection] */= [
			['rgb(75,43,24)', 'rgb(139,79,45)'],
			['rgb(255,255,255)', 'rgb(200,200,200)'],
			['rgb(64, 224, 208)', 'rgb(36,127,118)'],
		];

	const
		initialJumpVelocity /* maximum jump height */ = CONST.getWindowHeight() * 0.01,
		gravity = initialJumpVelocity / 10;

	// miniMap size
	const
		width = CONST.getWindowWidth(),
		height = CONST.getWindowHeight(),
		whicheverIsShorter = Math.min(width, height),
		miniMapMargin = whicheverIsShorter * 0.01,
		miniMapSizeMin = Math.floor(whicheverIsShorter * 0.2),
		miniMapSizeMax = Math.floor(whicheverIsShorter * 0.8),
		miniMapToggleSpeed = (miniMapSizeMax - miniMapSizeMin) / 5;

	Param.prototype.getMiniMapMargin = function() {
		return miniMapMargin
	};
	Param.prototype.getMiniMapSizeMin = function() {
		return miniMapSizeMin
	};
	Param.prototype.getMiniMapSizeMax = function() {
		return miniMapSizeMax
	};
	Param.prototype.getMiniMapToggleSpeed = function() {
		return miniMapToggleSpeed
	};
	//
	Param.prototype.getMapGrid = function() {
		return mapGrid
	};
	Param.prototype.getWallColorArray = function() {
		return wallColorArray
	};
	Param.prototype.getInitialJumpVelocity = function() {
		return initialJumpVelocity
	};
	Param.prototype.getGravity = function() {
		return gravity
	}
})();


function State() {
	// states
	this.currentJumpVelocity = 0;
	this.accumulatedJumpHeight = 0;
	//
	this.isTogglingMiniMap /* 1: enlarging, 0: false, -1: shrinking */ = 0;
	//
	this.gunPositionOffsetX = 0;
	this.gunPositionOffsetY = 0;
	this.gunPositionOffsetXIncrementSign = 1;
	this.gunPositionOffsetYIncrementSign = 1;
	this.isGunPositionFiringOffset = false;
	this.gunPositionFiringOffsetX = 0;
	this.gunPositionFiringOffsetY = 0;
	this.gunPositionFiringOffsetXIncrementSign = 1;
	this.gunPositionFiringOffsetYIncrementSign = 1;
	this.isFiring = false;
	this.isFireRequested = false;
	this.isReloadRequested = false;
	this.isReloading = false;
	this.muzzleRotate = Math.random() * Math.PI * 2;
	this.thisRoundFiringFinished = true;
	this.bulletHitX;
	this.bulletHitY;
	//
	this.canvasCenterTextOpacity = 1;
	this.canvasCenterTextOpacitySign = -1;
	this.isShowingNoAmmoText = false;
	//
	this.healthPoint = param.healthPointMax;
	this.currentMagzine = param.currentMagzineMax;
	this.totalMagzine = param.totalMagzineMax;
	this.isMagzineEmpty = false;
}

// init objects
const 
	param = new Param(),
	state = new State(),
	game = new Game();

function Player() {
	this.x /* init coordinate x */ = 5;
	this.y /* init coordinate y */ = Math.floor(10 + Math.random() * 20);
	this.alpha /* init direction angle, relative to positive x axis */ = Math.random() > 0.5 ? (-0.75 * Math.PI * 2) /* up */: (0.25 * Math.PI * 2) /* down */;
	this.forward = false;
	this.backward = false;
	this.clockwise = false;
	this.counterClockwise = false;
	this.moveSpeed = 0.05;
	this.rotateSpeed = 0.01;
	this.mapGrid = param.getMapGrid();
	this.totalMagzine = 120;
	// related to jump function
	this.gravity = param.getGravity();
}
Player.prototype.move = function() {
	let moveState = this.forward ? 1 : this.backward ? -1 : 0;
	let rotateState = this.clockwise ? 1 : this.counterClockwise ? -1 : 0;

	if (moveState) {
		const nextX = this.x + this.moveSpeed * Math.cos(this.alpha) * moveState;
		const nextY = this.y + this.moveSpeed * Math.sin(this.alpha) * moveState;
		if (this.mapGrid[Math.floor(this.y)][Math.floor(nextX)] === 0) {
			this.x = nextX;
		}
		if (this.mapGrid[Math.floor(nextY)][Math.floor(this.x)] === 0) {
			this.y = nextY;
		}
	}

	if (rotateState) {
		this.alpha = this.rotateSpeed * rotateState + this.alpha;
	}

	//jump
	let currentJumpVelocity = state.currentJumpVelocity;
	const 
		gravity = this.gravity,
		jumpHiehtInThisFrame /* vt, t=1 here */ = currentJumpVelocity,
		accumulatedJumpHeightAfterThisJump = state.accumulatedJumpHeight + jumpHiehtInThisFrame;
	
	if (accumulatedJumpHeightAfterThisJump > 0) {
		// still jumping
		state.currentJumpVelocity = currentJumpVelocity - gravity;
		state.accumulatedJumpHeight += jumpHiehtInThisFrame;
	} else {
		// returned ground
		state.currentJumpVelocity = 0;
		state.accumulatedJumpHeight = 0;
	}
	// gun position offset
	if (this.forward || this.backward) {
		let 
			incrementX = Math.random(),
			incrementY = Math.random(),
			nextOffsetX = state.gunPositionOffsetX + incrementX * state.gunPositionOffsetXIncrementSign,
			nextOffsetY = state.gunPositionOffsetY + incrementY * state.gunPositionOffsetYIncrementSign;
		if (Math.abs(nextOffsetX) > param.gunPositionOffsetMax) {
			state.gunPositionOffsetXIncrementSign *= -1;
			nextOffsetX = state.gunPositionOffsetX + incrementX * state.gunPositionOffsetXIncrementSign;
		}
		if (Math.abs(nextOffsetY) > param.gunPositionOffsetMax) {
			state.gunPositionOffsetYIncrementSign *= -1;
			nextOffsetY = state.gunPositionOffsetY + incrementY * state.gunPositionOffsetYIncrementSign;
		}
		state.gunPositionOffsetX = nextOffsetX;
		state.gunPositionOffsetY = nextOffsetY;
	}
	// firing
	const 
		currentMagzineText  = document.getElementById('plaerStatusCurrentMagzine'),
		totalMagzineText  = document.getElementById('plaerStatusTotalMagzine');

	const reload = () => {
		if (state.currentMagzine === param.currentMagzineMax) {
			// full mag, no need to reload
			state.isReloadRequested = false;
			return;
		}
		state.isReloading = true;
		state.isFiring = false;
		state.thisRoundFiringFinished = true;
			setTimeout(() => {
				const roundRequired = param.currentMagzineMax - state.currentMagzine;
				if (roundRequired <= state.totalMagzine) {
					// normal reloading
					state.currentMagzine = param.currentMagzineMax;
					state.totalMagzine -= roundRequired;
				} else {
					// last mag not enough for full reload
					state.currentMagzine += state.totalMagzine;
					state.totalMagzine = 0;
				}

				if (state.totalMagzine === 0) {
					// mag empty
					const red = 'rgba(255, 69, 0, 1)';
					state.isMagzineEmpty = true;
					currentMagzineText.style.color = red;
					totalMagzineText.style.color = red;
				}
				// update text
				currentMagzineText.innerHTML = state.currentMagzine;
				totalMagzineText.innerHTML = state.totalMagzine;
				state.isReloading = false;
				state.isReloadRequested = false;
			}, 1000)
	};
	const fireNewRound = () => {
		const currentMagzine = state.currentMagzine;
		if (currentMagzine) {
			// still have bullet in current mag
			state.isFiring = true;
			state.thisRoundFiringFinished = false;
			state.muzzelRotate = Math.random() * Math.PI * 2;
			state.currentMagzine--;
			// bullet hit position
			const isMoving = this.forward || this.backward || state.currentJumpVelocity;
			const recoil = isMoving ? param.recoilMovingMax : param.recoilStaticMax;
			state.bulletHitX = CONST.getWindowWidth() * 0.5 + (Math.random() - 0.5) * recoil;
			state.bulletHitY = CONST.getWindowHeight() * 0.5 + (Math.random() - 0.5) * recoil;
			// update text
			currentMagzineText.innerHTML = state.currentMagzine;
			setTimeout(() => {
				state.thisRoundFiringFinished = true;
			}, 100)
			// recoil
			if (state.isGunPositionFiringOffset) {
				state.gunPositionFiringOffsetX = 0;
				state.gunPositionFiringOffsetY = 0;
				state.isGunPositionFiringOffset = false;
			} else {
				let 
					gunPositionFiringOffsetMax = param.gunPositionFiringOffsetMax,
					offsetX = gunPositionFiringOffsetMax * 0.5 + Math.random() * gunPositionFiringOffsetMax * 0.5,
					offsetY = gunPositionFiringOffsetMax * 0.5 + Math.random() * gunPositionFiringOffsetMax * 0.5;
				nextOffsetX = state.gunPositionFiringOffsetX + offsetX * state.gunPositionFiringOffsetXIncrementSign;
				nextOffsetY = state.gunPositionFiringOffsetY + offsetY * state.gunPositionFiringOffsetYIncrementSign;
				state.gunPositionFiringOffsetXIncrementSign *= -1;
				state.gunPositionFiringOffsetYIncrementSign *= -1;
				state.gunPositionFiringOffsetX = nextOffsetX;
				state.gunPositionFiringOffsetY = nextOffsetY;
				state.isGunPositionFiringOffset = true;
			}
		} else if (state.isMagzineEmpty) {
			// empty mag
			state.isFireRequested = false;
			if (!state.isShowingNoAmmoText) {
				state.isShowingNoAmmoText = true;
				setTimeout(() => {
					state.isShowingNoAmmoText = false;
				}, 1000)
			}
		} else if (!state.isMagzineEmpty) {
			// reload
			state.isReloadRequested = true;
		}
	};

	if (state.isReloading) {
		return
	} else if (state.isReloadRequested && !state.isMagzineEmpty) {
		reload()
	} else if (state.isFireRequested && state.thisRoundFiringFinished) {
		fireNewRound()
	} else if (!state.isFireRequested && state.isFiring) {
		// enter key released
		state.isFiring = false;
	}
};
function Game() {
	this.mainPlayer;
	this.otherPlayers = [];
	//
	this.wallDistArray;
	this.hitWallTypeArray;
	this.hitDirectionArray;
	this.rayAngleArray;
	this.wallDistArrayBeforeFishEyeCorrection; // for drawing ray on minimap
	this.fov = Math.PI / 3; //60 degree
	this.dAlpha; /* angle between rays */
	// get vars from param
	this.mapGrid = param.getMapGrid();
	//
	this.miniMapSizeMax = param.getMiniMapSizeMax();
	this.miniMapSizeMin = param.getMiniMapSizeMin();
	this.miniMapSize = this.miniMapSizeMin;
	this.miniMapMargin = param.getMiniMapMargin();
	this.miniMapToggleSpeed = param.getMiniMapToggleSpeed();
}
Game.prototype.initiateCanvas = function() {
	const rootDiv = document.getElementById('root');
	const container = document.createElement('div');
	rootDiv.appendChild(container);
	const width = CONST.getWindowWidth();
	const height = CONST.getWindowHeight();

	const mainCanvas = `<canvas id="mainCanvas" width=${width} height=${height}>Your Browser Does Not Support Html5 Canvas</canvas>`;
	container.innerHTML = mainCanvas;

	// instructionComponent
	const instructionComponent = new InstructionComponent();
	instructionComponent.mountComponent();
	// toolbar
	const toolBarComponent = new ToolBarComponent();
	toolBarComponent.mountComponent();
	// player stats
	const playerStatusComponent = new PlayerStatusComponent();
	playerStatusComponent.mountComponent();
};
Game.prototype.createPlayers = function() {
	this.mainPlayer = new Player();
	const player1 = new Player();
	this.otherPlayers.push(player1);
};
Game.prototype.ray = function() {
	//Prepare rayArray
	const 
		rayAngleArray = [],
		raydistArray = [],
		raydistArrayFishEyeCorrected = [],
		hitDirectionArray = [],
		hitWallTypeArray = [],
		mapGrid = this.mapGrid,
		width = CONST.getWindowWidth(),
		height = CONST.getWindowHeight(),
		resolution = param.resolution,
		dAlpha = (this.fov / (width / resolution));
	this.dAlpha = dAlpha;
	let rayAngle /* init first ray */ = this.mainPlayer.alpha - 0.5 * this.fov;
	//
	for (let i = 0; i < width; i += resolution) {
		rayAngleArray.push(rayAngle);
		rayAngle += dAlpha;
	}
	//
	rayAngleArray.map((i, index) => {
		const 
			result = raycaster(this.mainPlayer.x, this.mainPlayer.y, rayAngleArray[index]),
			dist = result[0],
			hitDirection = result[1],
			hitWallType = result[2],
			fishEyeCorrection = Math.abs(Math.cos(rayAngleArray[index] - this.mainPlayer.alpha));

		raydistArray.push(dist);
		raydistArrayFishEyeCorrected.push(dist * fishEyeCorrection);
		hitDirectionArray.push(hitDirection);
		hitWallTypeArray.push(hitWallType);
	})
	// update arrays in properties
	this.wallDistArrayBeforeFishEyeCorrection = raydistArray;
	this.wallDistArray = raydistArrayFishEyeCorrected;
	this.hitWallTypeArray = hitWallTypeArray;
	this.hitDirectionArray = hitDirectionArray;
	this.rayAngleArray = rayAngleArray;

	// raycaster
	function raycaster(x, y, alpha) {
		//input origin x,y and angle alpha, return distance.
		function checkHit (x, y) {
			// hit if grid value is not 0
			return mapGrid[y][x] !== 0
		}
		const 
			sin = Math.sin(alpha),
			cos = Math.cos(alpha),
			tan = Math.tan(alpha),
			result = [];
		// temp variables used for calculation
		let vx, vy, hx, hy, dist, distV, distH, hitDirection /* 0: horizontal, 1:vertical */, hitWallType;

		//2 tan>0 x++ y++
		if (sin >= 0 && cos > 0) {
			//vertical
			vx = Math.ceil(x);
			vy = Math.min(y + tan * (vx - x), 39);
			while (!checkHit(Math.floor(vx),Math.floor(vy))) {
				vx++;
				vy = Math.min(vy + tan, 39);
			}
			//horizontal
			hy = Math.ceil(y); //DO NOT REVERSE HY HX!
			hx = x + (hy - y)/tan;
			while (!checkHit(Math.floor(hx),Math.floor(hy))) {
				hx += 1/tan;
				hy++;
			}
			distV = Math.pow((vx-x)*(vx-x)+(vy-y)*(vy-y), 0.5);
			distH = Math.pow((hx-x)*(hx-x)+(hy-y)*(hy-y), 0.5);
			if (distV >= distH) {
				dist = distH;
				hitDirection = 0;
				hitWallType = mapGrid[Math.floor(hy)][Math.floor(hx)];
			} else {
				dist = distV;
				hitDirection = 1;
				hitWallType = mapGrid[Math.floor(vy)][Math.floor(vx)];
			}
		}
		
		//4 tan<0 x-- y++
		if (sin > 0 && cos <= 0) {
			//vertical
			vx = Math.floor(x);
			vy = Math.min(y + tan * (vx - x), 39);
			while (!checkHit(Math.floor(vx)-1,Math.floor(vy))) {
				vx--;
				vy = Math.min(vy - tan, 39);
			}
			//horizontal
			hy = Math.ceil(y); //DO NOT REVERSE HY HX!
			hx = x + (hy - y)/tan;
			while (!checkHit(Math.floor(hx),Math.floor(hy))) {
				hx += 1/tan;
				hy++;
			}
			distV = Math.pow((vx-x)*(vx-x)+(vy-y)*(vy-y),0.5);
			distH = Math.pow((hx-x)*(hx-x)+(hy-y)*(hy-y),0.5);
			if (distV >= distH) {
				dist = distH;
				hitDirection = 0;
				hitWallType = mapGrid[Math.floor(hy)][Math.floor(hx)];
			} else {
				dist = distV;
				hitDirection = 1;
				hitWallType = mapGrid[Math.floor(vy)][Math.floor(vx)-1];
			}
		}
		
		//6 tan>0 x-- y--
		if (sin <= 0 && cos < 0) {
			//vertical
			vx = Math.floor(x);
			vy = Math.max(y + tan * (vx - x), 1);
			while (!checkHit(Math.floor(vx)-1,Math.floor(vy))) {
				vx--;
				vy = Math.max(vy - tan, 1);
			}
			//horizontal
			hy = Math.floor(y); //DO NOT REVERSE HY HX!
			hx = x + (hy - y)/tan;
			while (!checkHit(Math.floor(hx),Math.floor(hy)-1)) {
				hx -= 1/tan;
				hy--;
			}
			distV = Math.pow((vx-x)*(vx-x)+(vy-y)*(vy-y),0.5);
			distH = Math.pow((hx-x)*(hx-x)+(hy-y)*(hy-y),0.5);
			if (distV >= distH) {
				dist = distH;
				hitDirection = 0;
				hitWallType = mapGrid[Math.floor(hy)-1][Math.floor(hx)];
			} else {
				dist = distV;
				hitDirection = 1;
				hitWallType = mapGrid[Math.floor(vy)][Math.floor(vx)-1];
			}
		}
		
		//8 tan<0 x++ y--
		if (sin < 0 && cos >= 0) {
			//vertical
			vx = Math.ceil(x);
			vy = Math.max(y + tan * (vx - x), 1);
			while (!checkHit(Math.floor(vx),Math.floor(vy))) {
				vx++;
				vy = Math.max(vy + tan, 1);
			}
			//horizontal
			hy = Math.floor(y); //DO NOT REVERSE HY HX!
			hx = x + (hy - y)/tan;
			while (!checkHit(Math.floor(hx),Math.floor(hy)-1)) {
				hx -= 1/tan;
				hy--;
			}
			distV = Math.pow((vx-x)*(vx-x)+(vy-y)*(vy-y),0.5);
			distH = Math.pow((hx-x)*(hx-x)+(hy-y)*(hy-y),0.5);
			if (distV >= distH) {
				dist = distH;
				hitDirection = 0;
				hitWallType = mapGrid[Math.floor(hy)-1][Math.floor(hx)];
			} else {
				dist = distV;
				hitDirection = 1;
				hitWallType = mapGrid[Math.floor(vy)][Math.floor(vx)];
			}
		}
		
		//
		result.push(dist);
		result.push(hitDirection);
		result.push(hitWallType);
		return result;
	}
}
Game.prototype.drawFrame = function() {
	const 
		width = CONST.getWindowWidth(),
		height = CONST.getWindowHeight(),
		ctx = document.getElementById('mainCanvas').getContext('2d');
	ctx.clearRect(0, 0, width, height);

//sky
	const
		sky = document.getElementById("sky"),
		skyWidth = sky.width,
		skyHeight = sky.height,
		playerAlpha =  this.mainPlayer.alpha,
		twoPI = Math.PI * 2,
		cameraAngle = playerAlpha % twoPI,
		direction = cameraAngle > 0 ?
			cameraAngle / twoPI :
			(twoPI + cameraAngle) / twoPI;

	ctx.drawImage(sky, direction*skyWidth, 0, 0.25*skyWidth, skyHeight, 0, 0, width, 0.6*height);
	if (direction >= 0.75) {
		ctx.drawImage(sky, 0, 0, 0.25*skyWidth, skyHeight, (1-direction)/0.25*width, 0, width, 0.6*height);
	}
//floor
	ctx.beginPath();
	ctx.fillStyle = 'rgba(150,150,150,1)';
	ctx.fillRect(0, 0.5 * height, width, 0.5 * height);
	ctx.fill();
//wall
	const wallDistArray = this.wallDistArray.slice();
	wallDistArray.map((i, index) => {
		const 
			columnHeightPercent = 3 / i,
			halfWallHeight = 0.5 * columnHeightPercent * height,
			mid = 0.5 * height,
			wallStart = mid - halfWallHeight,
			wallEnd = mid + halfWallHeight,
			hitWallType = this.hitWallTypeArray[index],
			hitDirection = this.hitDirectionArray[index],
			resolution = param.resolution;

		const wallColorArray = param.getWallColorArray();
		const wallColor = wallColorArray[hitWallType - 1][hitDirection];
		ctx.fillStyle = wallColor;
		ctx.beginPath();
		ctx.fillRect(index * resolution, wallStart + state.accumulatedJumpHeight, resolution, wallEnd - wallStart);
		ctx.fill();
	})

	// otherplayer
	this.drawOtherPlayers(this.otherPlayers[0]);

	//crosshair
	const isMoving = this.mainPlayer.forward || this.mainPlayer.backward || state.currentJumpVelocity;
	const crosshairSize = isMoving ? 15 : 0;

	ctx.strokeStyle = "rgba(0,255,0,1)";
	ctx.beginPath();
	ctx.moveTo(0.5*width-20-crosshairSize,0.5*height);
	ctx.lineTo(0.5*width-5-crosshairSize,0.5*height);
	ctx.stroke();
	ctx.beginPath();
	ctx.moveTo(0.5*width+5+crosshairSize,0.5*height);
	ctx.lineTo(0.5*width+20+crosshairSize,0.5*height);
	ctx.stroke();
	ctx.beginPath();
	ctx.moveTo(0.5*width,0.5*height-20-crosshairSize);
	ctx.lineTo(0.5*width,0.5*height-5-crosshairSize);
	ctx.stroke();
	ctx.beginPath();
	ctx.moveTo(0.5*width,0.5*height+5+crosshairSize);
	ctx.lineTo(0.5*width,0.5*height+20+crosshairSize);
	ctx.stroke();

	// gun
	const
		gun = document.getElementById("gun"),
		gunWidthSource = gun.width,
		gunHeightSource = gun.height,
		gunPosStartX = 0.5*width + state.gunPositionOffsetX + state.gunPositionFiringOffsetX,
		gunPosStartY = 0.6*height + state.gunPositionOffsetY + param.gunPositionOffsetMax + state.gunPositionFiringOffsetX + param.gunPositionFiringOffsetMax,
		gunWidth = 0.4*width,
		gunHeight = 0.4*height;
	if (state.isFiring) {
		const 
			muzzle = document.getElementById("muzzle"),
			muzzleWidthSource = muzzle.width,
			muzzleHeightSource = muzzle.height,
			muzzleHeight = 0.2 * gunWidth,
			muzzleWidth = muzzleHeight,
			muzzleCenterX = gunPosStartX + gunWidth * (5.4 / 20.7),
			muzzleCenterY = gunPosStartY + gunHeight * (1.7 / 13.2),
			muzzlePosStartX = 0 - 0.5 * muzzleWidth, /* after translate, muzzle center is 0,0 */
			muzzlePosStartY = 0 - 0.5 * muzzleHeight;
			// draw muzzle
		ctx.translate(muzzleCenterX, muzzleCenterY);
		ctx.rotate(state.muzzelRotate);
		ctx.drawImage(muzzle, 0, 0, muzzleWidthSource, muzzleHeightSource, muzzlePosStartX, muzzlePosStartY, muzzleWidth, muzzleHeight);
		ctx.rotate(-state.muzzelRotate);
		ctx.translate(-muzzleCenterX, -muzzleCenterY);
		// draw crater
		ctx.fillStyle = 'rgb(0,0,0)';
		ctx.beginPath();
		ctx.arc(state.bulletHitX, state.bulletHitY, 2, 0, 2 * Math.PI);
		ctx.fill();
	}
	ctx.drawImage(gun, 0, 0, gunWidthSource, gunHeightSource, gunPosStartX, gunPosStartY, gunWidth, gunHeight);

	// reloading text
	const flasingText = (messageString) => {
		ctx.font = "36px csFont";
		if (state.canvasCenterTextOpacity >= 0.5 && state.canvasCenterTextOpacity <= 1) {
			state.canvasCenterTextOpacity = state.canvasCenterTextOpacity + 0.1 * state.canvasCenterTextOpacitySign
		}
		if (state.canvasCenterTextOpacity < 0.5) {
			state.canvasCenterTextOpacity = 0.5;
			state.canvasCenterTextOpacitySign = 1;
		} else if (state.canvasCenterTextOpacity > 1) {
			state.canvasCenterTextOpacity = 1;
			state.canvasCenterTextOpacitySign = -1;
		}
		ctx.fillStyle = "rgba(255, 0, 0, " + state.canvasCenterTextOpacity + ")";
		ctx.textAlign = "center";
		ctx.fillText(messageString, width * 0.5, height * 0.6); 
	}
	if (state.isReloading) {
		flasingText('RELOADING')
	}
	// no ammo text
	if (state.isShowingNoAmmoText) {
		flasingText('RAN OUT OF AMMO')
	}
	// Minimap
	this.drawMinimap();
}
Game.prototype.drawOtherPlayers = function(otherPlayer) {
	const 
		x1 = this.mainPlayer.x,
		y1 = this.mainPlayer.y,
		x2 = otherPlayer.x,
		y2 = otherPlayer.y,
		dx = x2 - x1,
		dy = y2 - y1,
		z = Math.pow(dx*dx + dy*dy, 0.5),
		twoPI = Math.PI * 2;
		rayAngleArray = this.rayAngleArray.slice(),
		width = CONST.getWindowWidth(),
		height = CONST.getWindowHeight();
	let anotherPlayersAngleToMainPlayer;
	// dy is reversed in canvas cordinate, and our 0 deg is x-positive !!
	if (dx === 0 && dy === 0) {
		anotherPlayersAngleToMainPlayer = 0;
	} else if (dx === 0) {
		if (dy > 0) {
			anotherPlayersAngleToMainPlayer = 0.25 * twoPI
		} else if (dy < 0) {
			anotherPlayersAngleToMainPlayer = 0.75 * twoPI
		}
	} else if (dy === 0) {
		if (dx > 0) {
			anotherPlayersAngleToMainPlayer = 0
		} else if (dx < 0){
			anotherPlayersAngleToMainPlayer = 0.5 * twoPI
		}
	} else if (dx > 0 && dy > 0) {
		anotherPlayersAngleToMainPlayer = Math.atan(dy / dx);
	} else if (dx < 0 && dy > 0) {
		anotherPlayersAngleToMainPlayer = twoPI * 0.5 - Math.atan(dy / -dx);
	} else if (dx < 0 && dy < 0) {
		anotherPlayersAngleToMainPlayer = Math.atan(-dy / -dx) + twoPI * 0.5;
	} else if (dx > 0 && dy < 0) {
		anotherPlayersAngleToMainPlayer = twoPI - Math.atan(-dy / dx);
	} 
	anotherPlayersAngleToMainPlayer = remapAngleToZeroToTwoPI(anotherPlayersAngleToMainPlayer);

	function remapAngleToZeroToTwoPI(angle) {
		const twoPI = Math.PI * 2;
		let a = angle % twoPI;
		return a > 0 ? a : twoPI + a
	}
	function checkIfAnotherPlayerIsInSight(sightStartAngle, sightEndAngle, fov, anotherPlayersAngleToMainPlayer) {
		const end = remapAngleToZeroToTwoPI(sightEndAngle);
		let start = remapAngleToZeroToTwoPI(sightStartAngle); 
		//console.log(start * 360 / Math.PI / 2, end * 360 / Math.PI / 2, anotherPlayersAngleToMainPlayer* 360 / Math.PI / 2)
		if (end < fov) {
			if ((start < anotherPlayersAngleToMainPlayer && anotherPlayersAngleToMainPlayer < Math.PI * 2) || (0 < anotherPlayersAngleToMainPlayer && anotherPlayersAngleToMainPlayer < end)) {
				return true
			} else {
				return false
			}
		} else {
			if (start < anotherPlayersAngleToMainPlayer && anotherPlayersAngleToMainPlayer < end) {
				return true;
			} else {
				return false;
			}
		}
	}
	const drawOtherPlayer = (otherPlayer, anotherPlayersAngleToMainPlayer) => {
		const 
			playerMaxWidth = 500,
			playerMaxHeight = 800,
			distance = z * Math.cos(anotherPlayersAngleToMainPlayer),
			playerCurrentWidth = playerMaxWidth / z,
			playerCurrentHeight = playerMaxHeight / z;

		const end = remapAngleToZeroToTwoPI(rayAngleArray[rayAngleArray.length - 1]);
		let start = remapAngleToZeroToTwoPI(rayAngleArray[0]); 
		let player1PosOnScreen;

		if (anotherPlayersAngleToMainPlayer < start) {
			// this function is called when another player is garanteed in sight
			anotherPlayersAngleToMainPlayer += Math.PI * 2
		}
		otherPlayerPosOnScreen = Math.floor((anotherPlayersAngleToMainPlayer - start) / this.dAlpha);
		const wallDistAtThisPos = this.wallDistArrayBeforeFishEyeCorrection[otherPlayerPosOnScreen];
		if (z < wallDistAtThisPos) {
			// check if another player is blocked by wall is HERE!!
			const ctx = document.getElementById('mainCanvas').getContext('2d');
			ctx.fillStyle = 'red';
			ctx.beginPath();
			ctx.fillRect((otherPlayerPosOnScreen * param.resolution - playerCurrentWidth / 2), (height - playerCurrentHeight) / 2 + state.accumulatedJumpHeight, playerCurrentWidth, playerCurrentHeight);
			ctx.fill();
		}
	}

	const isOtherPlayerInSight = checkIfAnotherPlayerIsInSight(rayAngleArray[0], rayAngleArray[rayAngleArray.length - 1], this.fov, anotherPlayersAngleToMainPlayer);

	if (isOtherPlayerInSight) {
		drawOtherPlayer(otherPlayer, anotherPlayersAngleToMainPlayer);
	}
}
Game.prototype.drawMinimap = function() {
	// variables
	const 
		ctx = document.getElementById('mainCanvas').getContext('2d'),
		miniMapMargin /* eg: top =left = 10px */= this.miniMapMargin,
		mapGrid = this.mapGrid.slice(),
		mapGridSize /* it's a square */ = mapGrid.length,
		miniMapSize /* it's a square */ = this.miniMapSize,
	 	pixel /* unit pixel for one grid, eg: 200/40=5px */ = miniMapSize / mapGridSize,
	 	rayAngleArray = this.rayAngleArray.slice(),
	 	wallDistArray = this.wallDistArrayBeforeFishEyeCorrection.slice(),
	 	playerXOnMinimap = this.mainPlayer.x * pixel + miniMapMargin,
	 	playerYOnMinimap = this.mainPlayer.y * pixel + miniMapMargin,
	 	isTogglingMiniMap /* 1: enlarging, 0: false, -1: shrinking */ = state.isTogglingMiniMap,
		miniMapSizeInNextFrame = miniMapSize + isTogglingMiniMap * this.miniMapToggleSpeed;

	// toggling minimap
	if (isTogglingMiniMap) {
		// indeed is toggling
		if (miniMapSizeInNextFrame >= this.miniMapSizeMax || miniMapSizeInNextFrame <= this.miniMapSizeMin) {
			// last frame
			this.miniMapSize = isTogglingMiniMap === 1 ? this.miniMapSizeMax : this.miniMapSizeMin
		} else {
			this.miniMapSize = miniMapSizeInNextFrame
		}
	}

	// wall
	for (let y=0; y<mapGridSize; y++) {
		for (let x=0; x<mapGridSize; x++){
			if (mapGrid[y][x]) {
				ctx.fillStyle = "rgba(0,150,0,0.5)";
				ctx.fillRect(x * pixel + miniMapMargin, y * pixel + miniMapMargin, pixel, pixel);
			}
		}
	}
	// player
	ctx.fillStyle = "red";
	ctx.beginPath();
	ctx.arc(playerXOnMinimap, playerYOnMinimap, miniMapSize / 100, 0 , 2 * Math.PI);
	ctx.fill();
	// rays
	rayAngleArray.map((i, index) => {
		const thisRayLength = wallDistArray[index];
		ctx.strokeStyle = "rgba(0,255,0,0.01)";
		ctx.beginPath();
		ctx.moveTo(playerXOnMinimap, playerYOnMinimap);
		ctx.lineTo(playerXOnMinimap + pixel * thisRayLength * Math.cos(i), playerYOnMinimap + pixel * thisRayLength * Math.sin(i));
		ctx.stroke();
	})
	// direction pointer
	ctx.strokeStyle = "black";
	ctx.beginPath();
	ctx.moveTo(playerXOnMinimap, playerYOnMinimap);
	ctx.lineTo(playerXOnMinimap + pixel * Math.cos(this.mainPlayer.alpha), playerYOnMinimap + pixel * Math.sin(this.mainPlayer.alpha));
	ctx.stroke();
	// grid
	for (let i = 0; i <= mapGridSize; i++) {
		const 
			start = i * pixel + miniMapMargin,
			end = mapGridSize * pixel + miniMapMargin;
		ctx.strokeStyle = "rgba(0,150,0,0.1)";
		ctx.beginPath();
		ctx.moveTo(miniMapMargin, start);
		ctx.lineTo(end, start);
		ctx.moveTo(start, miniMapMargin);
		ctx.lineTo(start, end);
		ctx.stroke();
	}
}
Game.prototype.attachEventListeners = function() {
	const player = this.mainPlayer;
	document.addEventListener('keydown', function(e) {
					switch(e.keyCode){
						case 65:
							player.counterClockwise = true;
							break;
						case 87:
							player.forward = true;
							break;
						case 68:
							player.clockwise = true;
							break;
						case 83:
							player.backward = true;
							break;
						case 32:
							if(!state.currentJumpVelocity) state.currentJumpVelocity = param.getInitialJumpVelocity();
							break;
						case 77:
							const isTogglingMiniMap = state.isTogglingMiniMap;
							state.isTogglingMiniMap = !isTogglingMiniMap ?
														1 :
														isTogglingMiniMap === 1 ?
														-1 :
														1;

							break;
						case 13:
							if(!state.isFireRequested) state.isFireRequested = true;
							break;
						case 82:
							if(!state.isReloadRequested) state.isReloadRequested = true;
							break;
					}
})
document.addEventListener('keyup', function(e) {
					switch(e.keyCode){
						case 65:
							player.counterClockwise = false;
							break;
						case 87:
							player.forward = false;
							break;
						case 68:
							player.clockwise = false;
							break;
						case 83:
							player.backward = false;
							break;
						case 13:
							state.isFireRequested = false;
							break;	
					}
})
}
Game.prototype.play = function() {
	game.initiateCanvas();
	game.createPlayers();
	game.attachEventListeners();

	const frame = () => {
		this.mainPlayer.move();
		this.ray();
		this.drawFrame();
		requestAnimationFrame(frame);
	}
	requestAnimationFrame(frame);
}

function Loading() {
	this.loaded = 0;
	this.total = 1;
	this.isLoaded /* count */= 0;
}
Loading.prototype.sendRequest = function() {
	// this will also initiate CONST.assetsCount, which will be used in this.drawLoadingPage
	const urlObj = CONST.getAssetsUrlObj();

	function appendImg(url, elId) {
		const div = document.createElement('div');
		div.style.display = 'none';
		const img = document.createElement('img');
		img.id = elId;
		img.src = url;
		div.appendChild(img);
		document.getElementById('root').appendChild(div);
	}
	const loadImgThenAppendToDom = (url, elId) => {
		const xml = new XMLHttpRequest();
		let 
			thisTotalAddedToSumTotal = false,
			loaded = 0;

		xml.open('GET', url, true);
		xml.onprogress = (e) => {
			const loadedIncrement = e.loaded - loaded;
			this.loaded += loadedIncrement;
			loaded = e.loaded;
			// add total only on first time
			if (!thisTotalAddedToSumTotal) {
				this.total += e.total;
				thisTotalAddedToSumTotal = true;
			}
		};
		xml.onload = () => {
			appendImg(url, elId);
			this.isLoaded += 1;
		}
		xml.send();
	};

	for (let key in urlObj) {
		if (urlObj.hasOwnProperty(key)) {
			loadImgThenAppendToDom(urlObj[key], key)
		}
	}
}
Loading.prototype.drawLoadingPage = function() {
	const 
		rootDiv = document.getElementById('root'),
		width = CONST.getWindowWidth(),
		height = CONST.getWindowHeight(),
		centerX = 0.5 * width,
		centerY = 0.5 * height,
		radius = Math.pow(centerX * centerX + centerY * centerY, 0.5),
		PI = Math.PI;
		angleInOneFrame = PI * 2 / 120,
		startingAngle = 0 - PI * 0.5,
		loadingCanvas = `<canvas id="loadingCanvas" width=${width} height=${height}>Your Browser Does Not Support Html5 Canvas</canvas>`, 
		loadingMessage = 
			'<div class="loading-wrapper" id="loading-wrapper">' +
				'<p>Loading <span id="loadingPercentage">0</span>%<p>' +
			'</div>';
	rootDiv.innerHTML = loadingCanvas + loadingMessage;
	const 
		ctx = document.getElementById('loadingCanvas').getContext('2d'),
		wrapper = document.getElementById('loading-wrapper'),
		loadingPercentageSpan = document.getElementById('loadingPercentage');

	let 
		endingAngle = startingAngle,
		displayingPercentage = 0,
		textColorChangedToWhite = false;
	let frame = () => {
		const 
			loadingPercentage = Math.ceil((this.loaded / this.total) * 100),
			canvasPercentage = 100 * ((endingAngle - startingAngle) / (PI * 2));

		// update text
		if (displayingPercentage + 1 <= loadingPercentage) {
			displayingPercentage++;
			loadingPercentageSpan.innerHTML = displayingPercentage;
		}

		// change text color to white once loaded > 50%
		if (displayingPercentage > 50 && !textColorChangedToWhite) wrapper.className = 'loading-wrapper white-text';

		// canvas animation
		if (canvasPercentage < loadingPercentage) {
			ctx.clearRect(0, 0, width, height);
			ctx.beginPath();
			ctx.fillStyle = 'rgb(0, 172, 237)';
			ctx.moveTo(centerX, centerY)
			ctx.arc(centerX, centerY, radius, startingAngle, endingAngle += angleInOneFrame);
			ctx.fill();
		}

		if (canvasPercentage < 100 || this.isLoaded !== CONST.assetsCount) {
			// if the true loading speed is slower (slow 3g) than canvas animation epr frame speed, finishloading will be called before img append to DOM, therefore check this.isLoaded
			requestAnimationFrame(frame)
		} else {
			this.finishLoading()
		}
	}
	requestAnimationFrame(frame);
}
Loading.prototype.finishLoading = function() {
	game.play();
	const 
		loadingCanvas = document.getElementById('loadingCanvas'),
		loadingText = document.getElementById('loading-wrapper');
	loadingCanvas.style.transition = '2s';
	loadingCanvas.style.transitionDelay = '0.5s';
	loadingCanvas.style.opacity = '0';
	loadingText.style.transition = '2s';
	loadingText.style.transitionDelay = '0.5s';
	loadingText.style.opacity = '0';

	setTimeout(() => {
		loadingCanvas.parentNode.removeChild(loadingCanvas);
		loadingText.parentNode.removeChild(loadingText);
	}, 3000);
}

function InstructionComponent() {
	this.component;
	this.isDisplaying = true;
}
InstructionComponent.prototype.mountComponent = function() {
	const rootDiv = document.getElementById('root');
	const instructionComponent = document.createElement('div');
	instructionComponent.id = 'instructionComponent';
	instructionComponent.innerHTML = 
			'<h1>cs_assault.map</h1>' +
				'<ul>' +
					'<li>I: Open / close this window</li>' +
					'<li>W: Move Forward</li>' +
					'<li>S: Move Back</li>' +
					'<li>A: Turn Left</li>' +
					'<li>D: Turn Right</li>' +
					'<li>R: Reload</li>' +
					'<li>Enter: Fire</li>' +
					'<li>Space: Jump</li>' +
					'<li>M: Toggle Map Zooming</li>' +
				'</ul>' +
			'<h1>Many thanks to these tutorials:</h1>' +
				'<ul>' +
					'<li><a href="http://www.playfuljs.com/a-first-person-engine-in-265-lines/" target="_blank">PlayfulJS.com</a></li>' +
					'<li><a href="http://permadi.com/1996/05/ray-casting-tutorial-table-of-contents/" target="_blank">Permadi.com</a></li>' +
					'<li><a href="http://lodev.org/cgtutor/raycasting.html" target="_blank">Lodev.org</a></li>' +
				'</ul>' +
			'<h2><a href="https://www.xiaoxihome.com" target="_blank"><span>&copy; XIAOXIHOME.COM 2017~2018</span></a><h2>';
	rootDiv.appendChild(instructionComponent);
	this.component = instructionComponent;
	this.addEventListener();
	this.toggleDisplay();
}
InstructionComponent.prototype.addEventListener = function() {
	document.addEventListener('keydown', (e) => {
		if (e.keyCode === 73) {
			// button I
			this.toggleDisplay()
		}
	});
}
InstructionComponent.prototype.toggleDisplay = function() {
	if (this.isDisplaying) {
		this.component.style.opacity = 0;
		this.component.style.visibility = 'hidden';
	} else {
		this.component.style.opacity = 1;
		this.component.style.visibility = 'visible';
	}
	this.isDisplaying = !this.isDisplaying;
}
function ToolBarComponent() {
	const createDiv = (id) => {
		const div = document.createElement('div');
		div.id = id;
		return div;
	}
	const 
		toolBarComponent = createDiv('toolBarComponent'),
		info = createDiv('info'),
		setting = createDiv('setting'),
		settingDropdown = createDiv('settingDropdown');
		settingDropdownItem1 = createDiv('settingDropdownItem1');
	info.innerHTML = '<span><i class="fas fa-info-circle"></i></span>';
	setting.innerHTML = '<span><i class="fas fa-cog"></i></span>';
	const graphicToggleOn = () => {
		settingDropdownItem1.innerHTML = '<span>Lower graphic quality <i class="fas fa-toggle-on" style="color: green; font-size: 24px; top: .125em; position: relative""></i></span>';
		this.isLowerGraphicQuality = true;
		param.resolution = param.resolutionLow;
	}
	const graphicToggleOff = () => {
		settingDropdownItem1.innerHTML = '<span>Lower graphic quality <i class="fas fa-toggle-off" style="color: rgba(0,0,0,0.5); font-size: 24px; top: .125em; position: relative"></i></span>';
		this.isLowerGraphicQuality = false;
		param.resolution = param.resolutionHigh;
	}
	graphicToggleOff();

	info.onclick = () => {
		const event = new Event('keydown');
		event.keyCode = 73;
		document.dispatchEvent(event);
	}
	setting.onclick = () => {
		this.isSettingDropdownActive ? this.closeSettingDropdown() : this.openSettingDropdown();
	}
	settingDropdownItem1.onclick = (e) => {
		e.stopPropagation();
		this.isLowerGraphicQuality ? graphicToggleOff() : graphicToggleOn();
	}
	settingDropdown.onmouseleave = () => {
		this.closeSettingDropdown()
	}

	setting.appendChild(settingDropdown);
	toolBarComponent.appendChild(info);
	toolBarComponent.appendChild(setting);
	settingDropdown.appendChild(settingDropdownItem1);

	this.component = toolBarComponent;
	this.settingDropdownComponent = settingDropdown;
	this.isSettingDropdownActive = false;
	this.isLowerGraphicQuality = false;
}
ToolBarComponent.prototype.mountComponent = function() {
	const rootDiv = document.getElementById('root');
	rootDiv.appendChild(this.component);
}
ToolBarComponent.prototype.closeSettingDropdown = function() {
	if (this.isSettingDropdownActive) {
		const dropdown = this.settingDropdownComponent;
		dropdown.style.opacity = 0;
		dropdown.style.visibility = 'hidden'
		this.isSettingDropdownActive = false;
	}
}
ToolBarComponent.prototype.openSettingDropdown = function() {
	if (!this.isSettingDropdownActive) {
		const dropdown = this.settingDropdownComponent;
		dropdown.style.opacity = 1;
		dropdown.style.visibility = 'visible'
		this.isSettingDropdownActive = true;
	}
}

function PlayerStatusComponent() {
	this.component;
}
PlayerStatusComponent.prototype.mountComponent = function() {
	const rootDiv = document.getElementById('root');
	const playerStatusComponent = document.createElement('div');
	playerStatusComponent.id = 'playerStatusComponent';
	playerStatusComponent.innerHTML = 
			'<div class="playerStatusGroupWrapper">' +
				'<div class="playerStatusIcon" style="position: relative; top: -0.1em;">' +
					'<i class="fas fa-times-circle"></i>' +
				'</div>' +
				'<div class="playerStatusValue">' +
					'<span id="plaerStatusHealthPoint">' + state.healthPoint + '</span>' +
				'</div>' +
			'</div>' +
			'<div class="playerStatusGroupWrapper">' +
				'<div class="playerStatusIcon" style="position: relative; top: -0.4em;">' +
					'<i class="fas fa-joint"></i>' +
				'</div>' +
				'<div class="playerStatusValue">' +
					'<span id="plaerStatusCurrentMagzine">' + state.currentMagzine + '</span>' + '|' + '<span id="plaerStatusTotalMagzine">' + state.totalMagzine + '</span>' +
				'</div>' +
			'</div>';
	rootDiv.appendChild(playerStatusComponent);
	this.component = playerStatusComponent;
}



window.onload = function() {
	const loading = new Loading();
	loading.sendRequest();
	loading.drawLoadingPage();
}



</script>
</body>
</html>